interface Theme {
    custom: {
      maxContentWidth: number;
      headerHeight: number;
      footerHeight: number;
    };
  }
interface ThemeOptions {
    custom?: {
      maxContentWidth?: number;
      headerHeight?: number;
      footerHeight?: number;
    };
  }
import { createTheme } from '@mui/material/styles';

declare module '@mui/material/styles' {
// Code for:   interface Theme {
  // Allow configuration using `createTheme`
// Code for:   interface ThemeOptions {
}

export const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
      contrastText: '#fff',
    },
    secondary: {
      main: '#9c27b0',
      light: '#ba68c8',
      dark: '#7b1fa2',
      contrastText: '#fff',
    },
    error: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828',
    },
    warning: {
      main: '#ed6c02',
      light: '#ff9800',
      dark: '#e65100',
    },
    info: {
      main: '#0288d1',
      light: '#03a9f4',
      dark: '#01579b',
    },
    success: {
      main: '#2e7d32',
      light: '#4caf50',
      dark: '#1b5e20',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
      disabled: 'rgba(0, 0, 0, 0.38)',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 500,
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 500,
      lineHeight: 1.3,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 500,
      lineHeight: 1.5,
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 4,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '8px 16px',
        },
        contained: {
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0px 2px 4px -1px rgba(0,0,0,0.2), 0px 4px 5px 0px rgba(0,0,0,0.14), 0px 1px 10px 0px rgba(0,0,0,0.12)',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
          transition: 'transform 0.2s, box-shadow 0.2s',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
        },
      },
    },
  },
  custom: {
    maxContentWidth: 1440,
    headerHeight: 64,
    footerHeight: 56,
  },
});
interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  imageUrl: string;
  category: string;
  stock: number;
  rating: number;
  reviews: Review[];
}
interface Review {
  id: string;
  userId: string;
  userName: string;
  rating: number;
  comment: string;
  date: string;
}
interface CartItem extends Product {
  quantity: number;
}
interface User {
  id: string;
  name: string;
  email: string;
  address?: Address;
  orders: Order[];
}
interface Address {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}
interface Order {
  id: string;
  date: string;
  items: OrderItem[];
  total: number;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled';
  shippingAddress: Address;
  paymentMethod: string;
}
interface OrderItem {
  productId: string;
  name: string;
  quantity: number;
  price: number;
  imageUrl: string;
}
// Code for: export interface Product {

// Code for: export interface Review {

// Code for: export interface CartItem extends Product {

// Code for: export interface User {

// Code for: export interface Address {

// Code for: export interface Order {

// Code for: export interface OrderItem {
/**
 * Validation utility functions for frontend forms
 */

/**
 * Validate email format
 * @param email Email to validate
 * @returns True if valid, false otherwise
 */
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

/**
 * Validate password strength
 * @param password Password to validate
 * @returns Object with validation result and message
 */
export const validatePassword = (password: string): { isValid: boolean; message: string } => {
  if (password.length < 8) {
    return { isValid: false, message: 'Password must be at least 8 characters long' };
  }
  
  if (!/[A-Z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one uppercase letter' };
  }
  
  if (!/[a-z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one lowercase letter' };
  }
  
  if (!/[0-9]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one number' };
  }
  
  return { isValid: true, message: 'Password is strong' };
};

/**
 * Validate that passwords match
 * @param password Password
 * @param confirmPassword Confirmation password
 * @returns True if matching, false otherwise
 */
export const passwordsMatch = (password: string, confirmPassword: string): boolean => {
  return password === confirmPassword;
};

/**
 * Validate phone number format
 * @param phone Phone number to validate
 * @returns True if valid, false otherwise
 */
export const isValidPhone = (phone: string): boolean => {
  const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
  return phoneRegex.test(phone);
};

/**
 * Validate required field
 * @param value Field value
 * @returns True if not empty, false otherwise
 */
export const isNotEmpty = (value: string): boolean => {
  return value.trim().length > 0;
};

/**
 * Validate minimum length
 * @param value Field value
 * @param minLength Minimum length
 * @returns True if valid, false otherwise
 */
export const hasMinLength = (value: string, minLength: number): boolean => {
  return value.length >= minLength;
};

/**
 * Validate maximum length
 * @param value Field value
 * @param maxLength Maximum length
 * @returns True if valid, false otherwise
 */
export const hasMaxLength = (value: string, maxLength: number): boolean => {
  return value.length <= maxLength;
};

/**
 * Validate numeric value
 * @param value Field value
 * @returns True if numeric, false otherwise
 */
export const isNumeric = (value: string): boolean => {
  return /^\d+$/.test(value);
};

/**
 * Validate decimal value
 * @param value Field value
 * @returns True if decimal, false otherwise
 */
export const isDecimal = (value: string): boolean => {
  return /^\d+(\.\d+)?$/.test(value);
};

/**
 * Validate URL format
 * @param url URL to validate
 * @returns True if valid, false otherwise
 */
export const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
};

/**
 * Validate postal/zip code format
 * @param code Postal/zip code to validate
 * @param countryCode Country code (default: 'US')
 * @returns True if valid, false otherwise
 */
export const isValidPostalCode = (code: string, countryCode: string = 'US'): boolean => {
  // Basic validation for common country formats
  const postalRegexes: { [key: string]: RegExp } = {
    US: /^\d{5}(-\d{4})?$/,
    CA: /^[A-Za-z]\d[A-Za-z][ -]?\d[A-Za-z]\d$/,
    UK: /^[A-Za-z]{1,2}\d[A-Za-z\d]? \d[A-Za-z]{2}$/,
    AU: /^\d{4}$/,
    DE: /^\d{5}$/,
    FR: /^\d{5}$/,
    IT: /^\d{5}$/,
    ES: /^\d{5}$/,
    NL: /^\d{4}[ ]?[A-Za-z]{2}$/,
    BE: /^\d{4}$/,
  };
  
  const regex = postalRegexes[countryCode] || postalRegexes.US;
  return regex.test(code);
};

/**
 * Validate credit card number using Luhn algorithm
 * @param cardNumber Credit card number to validate
 * @returns True if valid, false otherwise
 */
export const isValidCreditCard = (cardNumber: string): boolean => {
  // Remove spaces and dashes
  const sanitized = cardNumber.replace(/[\s-]/g, '');
  
  // Check if contains only digits
  if (!/^\d+$/.test(sanitized)) {
    return false;
  }
  
  // Check length (most cards are 13-19 digits)
  if (sanitized.length < 13 || sanitized.length > 19) {
    return false;
  }
  
  // Luhn algorithm
  let sum = 0;
  let double = false;
  
  // Loop from right to left
  for (let i = sanitized.length - 1; i >= 0; i--) {
    let digit = parseInt(sanitized.charAt(i), 10);
    
    if (double) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }
    
    sum += digit;
    double = !double;
  }
  
  return sum % 10 === 0;
};

/**
 * Validate credit card expiration date
 * @param month Expiration month (1-12)
 * @param year Expiration year (4 digits)
 * @returns True if valid and not expired, false otherwise
 */
export const isValidExpirationDate = (month: number, year: number): boolean => {
  const now = new Date();
  const currentMonth = now.getMonth() + 1; // getMonth() returns 0-11
  const currentYear = now.getFullYear();
  
  // Check if month is valid
  if (month < 1 || month > 12) {
    return false;
  }
  
  // Check if expired
  if (year < currentYear || (year === currentYear && month < currentMonth)) {
    return false;
  }
  
  return true;
};

/**
 * Validate CVV code
 * @param cvv CVV code
 * @param cardType Card type (default: 'visa')
 * @returns True if valid, false otherwise
 */
export const isValidCVV = (cvv: string, cardType: string = 'visa'): boolean => {
  // Remove spaces
  const sanitized = cvv.replace(/\s/g, '');
  
  // Check if contains only digits
  if (!/^\d+$/.test(sanitized)) {
    return false;
  }
  
  // American Express uses 4-digit CVV, others use 3-digit
  const expectedLength = cardType.toLowerCase() === 'amex' ? 4 : 3;
  
  return sanitized.length === expectedLength;
};
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';

// API base URL from environment variables
const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

// Default request timeout in milliseconds
const REQUEST_TIMEOUT = 30000;

// Create axios instance with default config
const axiosInstance: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: REQUEST_TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add auth token
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle common errors
axiosInstance.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    // Handle token expiration
    if (error.response?.status === 401) {
      // Clear token and redirect to login
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    
    // Handle server errors
    if (error.response?.status === 500) {
      console.error('Server error:', error);
    }
    
    return Promise.reject(error);
  }
);

/**
 * Generic API request function
 * @param method HTTP method
 * @param url API endpoint
 * @param data Request data
 * @param config Additional axios config
 * @returns Promise with response data
 */
const apiRequest = async <T = any>(
  method: string,
  url: string,
  data?: any,
  config?: AxiosRequestConfig
): Promise<T> => {
  try {
    const response: AxiosResponse<T> = await axiosInstance({
      method,
      url,
      data,
      ...config,
    });
    
    return response.data;
  } catch (error: any) {
    // Format error message
    let errorMessage = 'An unexpected error occurred';
    
    if (error.response) {
      // Server responded with an error status
      errorMessage = error.response.data?.message || `Error: ${error.response.status}`;
    } else if (error.request) {
      // Request was made but no response received
      errorMessage = 'No response from server. Please check your internet connection.';
    } else {
      // Error in setting up the request
      errorMessage = error.message;
    }
    
    // Create a custom error object
    const customError = new Error(errorMessage);
    (customError as any).originalError = error;
    (customError as any).status = error.response?.status;
    
    throw customError;
  }
};

// API methods
export const api = {
  /**
   * GET request
   * @param url API endpoint
   * @param config Additional axios config
   * @returns Promise with response data
   */
  get: <T = any>(url: string, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('get', url, undefined, config);
  },
  
  /**
   * POST request
   * @param url API endpoint
   * @param data Request data
   * @param config Additional axios config
   * @returns Promise with response data
   */
  post: <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('post', url, data, config);
  },
  
  /**
   * PUT request
   * @param url API endpoint
   * @param data Request data
   * @param config Additional axios config
   * @returns Promise with response data
   */
  put: <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('put', url, data, config);
  },
  
  /**
   * PATCH request
   * @param url API endpoint
   * @param data Request data
   * @param config Additional axios config
   * @returns Promise with response data
   */
  patch: <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('patch', url, data, config);
  },
  
  /**
   * DELETE request
   * @param url API endpoint
   * @param config Additional axios config
   * @returns Promise with response data
   */
  delete: <T = any>(url: string, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('delete', url, undefined, config);
  },
  
  /**
   * Upload file(s)
   * @param url API endpoint
   * @param formData FormData with files
   * @param onProgress Progress callback
   * @returns Promise with response data
   */
  upload: <T = any>(
    url: string,
    formData: FormData,
    onProgress?: (progressEvent: any) => void
  ): Promise<T> => {
    const config: AxiosRequestConfig = {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    };
    
    if (onProgress) {
      config.onUploadProgress = onProgress;
    }
    
    return apiRequest<T>('post', url, formData, config);
  },
};

export default api;
/**
 * Format a price with currency symbol
 * @param price Price to format
 * @param currency Currency code (default: USD)
 * @returns Formatted price string
 */
export const formatPrice = (price: number, currency: string = 'USD'): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(price);
};

/**
 * Format a date to a readable string
 * @param date Date to format
 * @param options Intl.DateTimeFormatOptions
 * @returns Formatted date string
 */
export const formatDate = (
  date: Date | string,
  options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }
): string => {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return new Intl.DateTimeFormat('en-US', options).format(dateObj);
};

/**
 * Format a date to a relative time string (e.g., "2 days ago")
 * @param date Date to format
 * @returns Relative time string
 */
export const formatRelativeTime = (date: Date | string): string => {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - dateObj.getTime()) / 1000);
  
  // Less than a minute
  if (diffInSeconds < 60) {
    return 'just now';
  }
  
  // Less than an hour
  if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  }
  
  // Less than a day
  if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  }
  
  // Less than a week
  if (diffInSeconds < 604800) {
    const days = Math.floor(diffInSeconds / 86400);
    return `${days} day${days > 1 ? 's' : ''} ago`;
  }
  
  // Less than a month
  if (diffInSeconds < 2592000) {
    const weeks = Math.floor(diffInSeconds / 604800);
    return `${weeks} week${weeks > 1 ? 's' : ''} ago`;
  }
  
  // Less than a year
  if (diffInSeconds < 31536000) {
    const months = Math.floor(diffInSeconds / 2592000);
    return `${months} month${months > 1 ? 's' : ''} ago`;
  }
  
  // More than a year
  const years = Math.floor(diffInSeconds / 31536000);
  return `${years} year${years > 1 ? 's' : ''} ago`;
};

/**
 * Truncate a string to a specified length
 * @param str String to truncate
 * @param maxLength Maximum length
 * @param suffix Suffix to add if truncated (default: "...")
 * @returns Truncated string
 */
export const truncateString = (
  str: string,
  maxLength: number,
  suffix: string = '...'
): string => {
  if (str.length <= maxLength) {
    return str;
  }
  
  return str.substring(0, maxLength - suffix.length) + suffix;
};

/**
 * Format a phone number to a readable format
 * @param phone Phone number to format
 * @returns Formatted phone number
 */
export const formatPhoneNumber = (phone: string): string => {
  // Remove all non-numeric characters
  const cleaned = phone.replace(/\D/g, '');
  
  // Check if the input is valid
  if (cleaned.length < 10) {
    return phone;
  }
  
  // Format the phone number
  if (cleaned.length === 10) {
    return `(${cleaned.substring(0, 3)}) ${cleaned.substring(3, 6)}-${cleaned.substring(6, 10)}`;
  }
  
  // Handle international numbers
  return `+${cleaned.substring(0, cleaned.length - 10)} (${cleaned.substring(cleaned.length - 10, cleaned.length - 7)}) ${cleaned.substring(cleaned.length - 7, cleaned.length - 4)}-${cleaned.substring(cleaned.length - 4)}`;
};

/**
 * Format a file size to a readable string
 * @param bytes Size in bytes
 * @param decimals Number of decimal places (default: 2)
 * @returns Formatted size string
 */
export const formatFileSize = (bytes: number, decimals: number = 2): string => {
  if (bytes === 0) {
    return '0 Bytes';
  }
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
};

/**
 * Format a number with commas
 * @param num Number to format
 * @returns Formatted number string
 */
export const formatNumber = (num: number): string => {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};
interface User {
  _id: string;
  name: string;
  email: string;
  role: 'user' | 'admin';
  avatar?: string;
  createdAt: string;
  updatedAt: string;
}
interface AuthResponse {
  success: boolean;
  message: string;
  data: {
    token: string;
    user: User;
  };
}
interface LoginCredentials {
  email: string;
  password: string;
}
interface RegisterData {
  name: string;
  email: string;
  password: string;
}
import api from './api';

// Code for: export interface User {

// Code for: export interface AuthResponse {

// Code for: export interface LoginCredentials {

// Code for: export interface RegisterData {

/**
 * Login user with email and password
 * @param credentials Login credentials
 * @returns Authentication response
 */
export const login = async (credentials: LoginCredentials): Promise<AuthResponse> => {
  const response = await api.post<AuthResponse>('/auth/login', credentials);
  
  if (response.success && response.data.token) {
    // Store token in localStorage
    localStorage.setItem('token', response.data.token);
    // Store user data in localStorage
    localStorage.setItem('user', JSON.stringify(response.data.user));
  }
  
  return response;
};

/**
 * Register a new user
 * @param userData User registration data
 * @returns Authentication response
 */
export const register = async (userData: RegisterData): Promise<AuthResponse> => {
  const response = await api.post<AuthResponse>('/auth/register', userData);
  
  if (response.success && response.data.token) {
    // Store token in localStorage
    localStorage.setItem('token', response.data.token);
    // Store user data in localStorage
    localStorage.setItem('user', JSON.stringify(response.data.user));
  }
  
  return response;
};

/**
 * Logout user
 */
export const logout = (): void => {
  // Remove token from localStorage
  localStorage.removeItem('token');
  // Remove user data from localStorage
  localStorage.removeItem('user');
  // Redirect to login page
  window.location.href = '/login';
};

/**
 * Get current authenticated user
 * @returns User object or null
 */
export const getCurrentUser = (): User | null => {
  const userString = localStorage.getItem('user');
  if (!userString) {
    return null;
  }
  
  try {
    return JSON.parse(userString) as User;
  } catch (error) {
    console.error('Error parsing user data:', error);
    return null;
  }
};

/**
 * Check if user is authenticated
 * @returns Boolean indicating if user is authenticated
 */
export const isAuthenticated = (): boolean => {
  return !!localStorage.getItem('token');
};

/**
 * Check if user is an admin
 * @returns Boolean indicating if user is an admin
 */
export const isAdmin = (): boolean => {
  const user = getCurrentUser();
  return user?.role === 'admin';
};

/**
 * Update user profile
 * @param userData User data to update
 * @returns Updated user data
 */
export const updateProfile = async (userData: Partial<User>): Promise<User> => {
  const response = await api.put<{ success: boolean; data: User }>('/auth/profile', userData);
  
  if (response.success) {
    // Update user data in localStorage
    const currentUser = getCurrentUser();
    const updatedUser = { ...currentUser, ...response.data };
    localStorage.setItem('user', JSON.stringify(updatedUser));
    
    return updatedUser;
  }
  
  throw new Error('Failed to update profile');
};

/**
 * Change user password
 * @param currentPassword Current password
 * @param newPassword New password
 * @returns Success message
 */
export const changePassword = async (
  currentPassword: string,
  newPassword: string
): Promise<string> => {
  const response = await api.put<{ success: boolean; message: string }>(
    '/auth/change-password',
    { currentPassword, newPassword }
  );
  
  if (response.success) {
    return response.message;
  }
  
  throw new Error('Failed to change password');
};

/**
 * Request password reset
 * @param email User email
 * @returns Success message
 */
export const requestPasswordReset = async (email: string): Promise<string> => {
  const response = await api.post<{ success: boolean; message: string }>(
    '/auth/forgot-password',
    { email }
  );
  
  if (response.success) {
    return response.message;
  }
  
  throw new Error('Failed to request password reset');
};

/**
 * Reset password with token
 * @param token Reset token
 * @param newPassword New password
 * @returns Success message
 */
export const resetPassword = async (
  token: string,
  newPassword: string
): Promise<string> => {
  const response = await api.post<{ success: boolean; message: string }>(
    '/auth/reset-password',
    { token, newPassword }
  );
  
  if (response.success) {
    return response.message;
  }
  
  throw new Error('Failed to reset password');
};
import axios from 'axios';
import { Product, Review, Order, User, CartItem } from '../types/product';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor to include auth token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const productApi = {
  getProducts: async (params?: { category?: string; search?: string; sort?: string }) => {
    const response = await api.get<Product[]>('/products', { params });
    return response.data;
  },
  
  getProductById: async (id: string) => {
    const response = await api.get<Product>(`/products/${id}`);
    return response.data;
  },
  
  createProduct: async (product: Omit<Product, 'id' | 'reviews' | 'rating'>) => {
    const response = await api.post<Product>('/products', product);
    return response.data;
  },
  
  updateProduct: async (id: string, updates: Partial<Product>) => {
    const response = await api.put<Product>(`/products/${id}`, updates);
    return response.data;
  },
  
  deleteProduct: async (id: string) => {
    await api.delete(`/products/${id}`);
  },
  
  addReview: async (productId: string, review: Omit<Review, 'id' | 'date'>) => {
    const response = await api.post<Review>(`/products/${productId}/reviews`, review);
    return response.data;
  },
};

export const cartApi = {
  getCart: async () => {
    const response = await api.get<CartItem[]>('/cart');
    return response.data;
  },
  
  addToCart: async (productId: string, quantity: number = 1) => {
    const response = await api.post<CartItem>('/cart/items', { productId, quantity });
    return response.data;
  },
  
  updateCartItem: async (productId: string, quantity: number) => {
    const response = await api.put<CartItem>(`/cart/items/${productId}`, { quantity });
    return response.data;
  },
  
  removeFromCart: async (productId: string) => {
    await api.delete(`/cart/items/${productId}`);
  },
  
  clearCart: async () => {
    await api.delete('/cart');
  },
};

export const orderApi = {
  getOrders: async () => {
    const response = await api.get<Order[]>('/orders');
    return response.data;
  },
  
  getOrderById: async (id: string) => {
    const response = await api.get<Order>(`/orders/${id}`);
    return response.data;
  },
  
  createOrder: async (orderData: {
    items: Array<{ productId: string; quantity: number }>;
    shippingAddress: {
      street: string;
      city: string;
      state: string;
      zipCode: string;
      country: string;
    };
    paymentMethod: string;
  }) => {
    const response = await api.post<Order>('/orders', orderData);
    return response.data;
  },
};

export const authApi = {
  login: async (credentials: { email: string; password: string }) => {
    const response = await api.post<{ token: string; user: User }>('/auth/login', credentials);
    return response.data;
  },
  
  register: async (userData: {
    name: string;
    email: string;
    password: string;
  }) => {
    const response = await api.post<{ token: string; user: User }>('/auth/register', userData);
    return response.data;
  },
  
  getCurrentUser: async () => {
    const response = await api.get<User>('/auth/me');
    return response.data;
  },
  
  updateProfile: async (updates: Partial<User>) => {
    const response = await api.put<User>('/auth/profile', updates);
    return response.data;
  },
};
import express, { Express, Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import morgan from 'morgan';
import dotenv from 'dotenv';
import path from 'path';

// Import routes
import authRoutes from './routes/auth.routes';
import productRoutes from './routes/product.routes';
import cartRoutes from './routes/cart.routes';
import orderRoutes from './routes/order.routes';
import userRoutes from './routes/user.routes';
import categoryRoutes from './routes/category.routes';
import reviewRoutes from './routes/review.routes';

// Import middleware
import { errorHandler } from './middleware/error.middleware';
import { authMiddleware } from './middleware/auth.middleware';

// Load environment variables
dotenv.config();

// Initialize Express app
const app: Express = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('dev'));

// Static files
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/products', productRoutes);
app.use('/api/cart', authMiddleware, cartRoutes);
app.use('/api/orders', authMiddleware, orderRoutes);
app.use('/api/users', authMiddleware, userRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/reviews', reviewRoutes);

// Health check endpoint
app.get('/health', (req: Request, res: Response) => {
  res.status(200).json({ status: 'ok', message: 'Server is running' });
});

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({ message: 'Route not found' });
});

// Error handling middleware
app.use(errorHandler);

// Connect to MongoDB and start server
const startServer = async () => {
  try {
    const mongoUri = process.env.MONGO_URI || 'mongodb://localhost:27017/ecommerce';
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');

    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to connect to MongoDB', error);
    process.exit(1);
  }
};

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (error) => {
  console.error('Unhandled Rejection:', error);
  process.exit(1);
});

// Start the server
startServer();
interface AppError extends Error {
  statusCode?: number;
  errors?: any[];
  code?: number;
}
import { Request, Response, NextFunction } from 'express';

// Code for: interface AppError extends Error {

export const errorHandler = (
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error('Error:', err);

  // Default error status and message
  let statusCode = err.statusCode || 500;
  let message = err.message || 'Internal Server Error';
  let errors = err.errors || [];

  // Handle mongoose validation errors
  if (err.name === 'ValidationError') {
    statusCode = 400;
    message = 'Validation Error';
    errors = Object.values((err as any).errors).map((error: any) => ({
      field: error.path,
      message: error.message,
    }));
  }

  // Handle mongoose duplicate key errors
  if (err.code === 11000) {
    statusCode = 400;
    message = 'Duplicate field value entered';
    
    const field = Object.keys((err as any).keyValue)[0];
    errors = [{ field, message: `${field} already exists` }];
  }

  // Handle mongoose cast errors
  if (err.name === 'CastError') {
    statusCode = 400;
    message = 'Invalid ID format';
    errors = [{ field: (err as any).path, message: 'Invalid format' }];
  }

  // Handle JWT errors
  if (err.name === 'JsonWebTokenError') {
    statusCode = 401;
    message = 'Invalid token';
  }

  if (err.name === 'TokenExpiredError') {
    statusCode = 401;
    message = 'Token expired';
  }

  // Send error response
  res.status(statusCode).json({
    success: false,
    message,
    errors: errors.length > 0 ? errors : undefined,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
  });
};
interface Request {
      user?: any;
    }
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/user.model';

// Extend Express Request interface to include user
declare global {
  namespace Express {
// Code for:     interface Request {
  }
}

export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        message: 'Authentication failed. No token provided or invalid format.',
      });
    }

    const token = authHeader.split(' ')[1];
    
    // Verify token
    const decoded: any = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    
    // Find user by id
    const user = await User.findById(decoded.id).select('-password');
    
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }
    
    // Add user to request object
    req.user = user;
    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    res.status(401).json({ message: 'Authentication failed. Invalid token.' });
  }
};

export const adminMiddleware = (req: Request, res: Response, next: NextFunction) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Access denied. Admin privileges required.' });
  }
};

export const optionalAuthMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return next();
    }

    const token = authHeader.split(' ')[1];
    
    const decoded: any = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    const user = await User.findById(decoded.id).select('-password');
    
    if (user) {
      req.user = user;
    }
    
    next();
  } catch (error) {
    // If token is invalid, just continue without setting user
    next();
  }
};
import Stripe from 'stripe';
import logger from './logger';

// Initialize Stripe with API key from environment variables
const stripeSecretKey = process.env.STRIPE_SECRET_KEY || 'dummy_key_for_development';
const stripe = new Stripe(stripeSecretKey, {
  apiVersion: '2023-10-16', // Use the latest API version
});

/**
 * Create a payment intent with Stripe
 * @param amount Amount in cents
 * @param currency Currency code (default: 'usd')
 * @param metadata Additional metadata
 * @returns Payment intent
 */
export const createPaymentIntent = async (
  amount: number,
  currency: string = 'usd',
  metadata: Record<string, string> = {}
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency,
      metadata,
      payment_method_types: ['card'],
    });
    
    logger.info(`Payment intent created: ${paymentIntent.id}`);
    return paymentIntent;
  } catch (error) {
    logger.error('Error creating payment intent:', error);
    throw error;
  }
};

/**
 * Retrieve a payment intent by ID
 * @param paymentIntentId Payment intent ID
 * @returns Payment intent
 */
export const retrievePaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    return paymentIntent;
  } catch (error) {
    logger.error(`Error retrieving payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Confirm a payment intent
 * @param paymentIntentId Payment intent ID
 * @param paymentMethodId Payment method ID
 * @returns Confirmed payment intent
 */
export const confirmPaymentIntent = async (
  paymentIntentId: string,
  paymentMethodId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.confirm(paymentIntentId, {
      payment_method: paymentMethodId,
    });
    
    logger.info(`Payment intent confirmed: ${paymentIntent.id}`);
    return paymentIntent;
  } catch (error) {
    logger.error(`Error confirming payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Cancel a payment intent
 * @param paymentIntentId Payment intent ID
 * @returns Canceled payment intent
 */
export const cancelPaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.cancel(paymentIntentId);
    
    logger.info(`Payment intent canceled: ${paymentIntent.id}`);
    return paymentIntent;
  } catch (error) {
    logger.error(`Error canceling payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Create a refund for a payment intent
 * @param paymentIntentId Payment intent ID
 * @param amount Amount to refund (in cents)
 * @param reason Reason for refund
 * @returns Refund
 */
export const createRefund = async (
  paymentIntentId: string,
  amount?: number,
  reason?: Stripe.RefundCreateParams.Reason
): Promise<Stripe.Refund> => {
  try {
    const refundParams: Stripe.RefundCreateParams = {
      payment_intent: paymentIntentId,
    };
    
    if (amount) {
      refundParams.amount = amount;
    }
    
    if (reason) {
      refundParams.reason = reason;
    }
    
    const refund = await stripe.refunds.create(refundParams);
    
    logger.info(`Refund created: ${refund.id} for payment intent ${paymentIntentId}`);
    return refund;
  } catch (error) {
    logger.error(`Error creating refund for payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Create a customer in Stripe
 * @param email Customer email
 * @param name Customer name
 * @param metadata Additional metadata
 * @returns Customer
 */
export const createCustomer = async (
  email: string,
  name: string,
  metadata: Record<string, string> = {}
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripe.customers.create({
      email,
      name,
      metadata,
    });
    
    logger.info(`Customer created: ${customer.id}`);
    return customer;
  } catch (error) {
    logger.error('Error creating customer:', error);
    throw error;
  }
};

/**
 * Add a payment method to a customer
 * @param customerId Customer ID
 * @param paymentMethodId Payment method ID
 * @returns Payment method
 */
export const attachPaymentMethod = async (
  customerId: string,
  paymentMethodId: string
): Promise<Stripe.PaymentMethod> => {
  try {
    const paymentMethod = await stripe.paymentMethods.attach(paymentMethodId, {
      customer: customerId,
    });
    
    logger.info(`Payment method ${paymentMethod.id} attached to customer ${customerId}`);
    return paymentMethod;
  } catch (error) {
    logger.error(`Error attaching payment method ${paymentMethodId} to customer ${customerId}:`, error);
    throw error;
  }
};

/**
 * Convert order amount to cents for Stripe
 * @param amount Amount in dollars
 * @returns Amount in cents
 */
export const convertToCents = (amount: number): number => {
  return Math.round(amount * 100);
};
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { Request } from 'express';
import { v4 as uuidv4 } from 'uuid';

// Define storage locations
const UPLOAD_DIR = path.join(__dirname, '../../uploads');
const PRODUCT_IMAGES_DIR = path.join(UPLOAD_DIR, 'products');
const USER_IMAGES_DIR = path.join(UPLOAD_DIR, 'users');
const CATEGORY_IMAGES_DIR = path.join(UPLOAD_DIR, 'categories');
const TEMP_DIR = path.join(UPLOAD_DIR, 'temp');

// Ensure upload directories exist
[UPLOAD_DIR, PRODUCT_IMAGES_DIR, USER_IMAGES_DIR, CATEGORY_IMAGES_DIR, TEMP_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Define file filter for images
const imageFileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  // Accept only image files
  if (!file.originalname.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
    return cb(new Error('Only image files are allowed!'));
  }
  cb(null, true);
};

// Create storage engine for product images
const productStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, PRODUCT_IMAGES_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create storage engine for user images
const userStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, USER_IMAGES_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create storage engine for category images
const categoryStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, CATEGORY_IMAGES_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create storage engine for temporary uploads
const tempStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, TEMP_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create multer instances
export const productUpload = multer({
  storage: productStorage,
  fileFilter: imageFileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
});

export const userUpload = multer({
  storage: userStorage,
  fileFilter: imageFileFilter,
  limits: {
    fileSize: 2 * 1024 * 1024, // 2MB
  },
});

export const categoryUpload = multer({
  storage: categoryStorage,
  fileFilter: imageFileFilter,
  limits: {
    fileSize: 3 * 1024 * 1024, // 3MB
  },
});

export const tempUpload = multer({
  storage: tempStorage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
  },
});

/**
 * Move a file from temp directory to target directory
 * @param filename Filename in temp directory
 * @param targetDir Target directory
 * @returns New file path
 */
export const moveFileFromTemp = (filename: string, targetDir: string): string => {
  const sourcePath = path.join(TEMP_DIR, filename);
  const targetPath = path.join(targetDir, filename);
  
  if (!fs.existsSync(sourcePath)) {
    throw new Error(`File ${filename} not found in temp directory`);
  }
  
  fs.copyFileSync(sourcePath, targetPath);
  fs.unlinkSync(sourcePath);
  
  return targetPath;
};

/**
 * Delete a file
 * @param filepath Path to file
 */
export const deleteFile = (filepath: string): void => {
  if (fs.existsSync(filepath)) {
    fs.unlinkSync(filepath);
  }
};

/**
 * Get public URL for a file
 * @param filepath Path to file
 * @returns Public URL
 */
export const getFileUrl = (filepath: string): string => {
  const relativePath = filepath.replace(UPLOAD_DIR, '');
  return `/uploads${relativePath.replace(/\\/g, '/')}`;
};
import winston from 'winston';
import path from 'path';

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Determine log level based on environment
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  return env === 'development' ? 'debug' : 'info';
};

// Define transports
const transports = [
  // Console transport
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.printf(
        (info) => `${info.timestamp} ${info.level}: ${info.message}`
      )
    ),
  }),
  // File transport for errors
  new winston.transports.File({
    filename: path.join(__dirname, '../../logs/error.log'),
    level: 'error',
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),
  // File transport for all logs
  new winston.transports.File({
    filename: path.join(__dirname, '../../logs/combined.log'),
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),
];

// Create logger instance
const logger = winston.createLogger({
  level: level(),
  levels,
  format: logFormat,
  transports,
  exitOnError: false,
});

export default logger;
interface ApiResponse<T> {
  success: boolean;
  message?: string;
  data?: T;
  errors?: any[];
  meta?: {
    pagination?: {
      page: number;
      limit: number;
      total: number;
      pages: number;
    };
    [key: string]: any;
  };
}
import { Response } from 'express';

/**
 * Standard API response format
 */
// Code for: interface ApiResponse<T> {

/**
 * Send a success response
 * @param res Express response object
 * @param data Response data
 * @param message Success message
 * @param statusCode HTTP status code
 * @param meta Additional metadata
 */
export const sendSuccess = <T>(
  res: Response,
  data?: T,
  message: string = 'Success',
  statusCode: number = 200,
  meta?: any
): Response<ApiResponse<T>> => {
  return res.status(statusCode).json({
    success: true,
    message,
    data,
    meta,
  });
};

/**
 * Send an error response
 * @param res Express response object
 * @param message Error message
 * @param statusCode HTTP status code
 * @param errors Array of specific errors
 */
export const sendError = (
  res: Response,
  message: string = 'Error',
  statusCode: number = 400,
  errors?: any[]
): Response<ApiResponse<null>> => {
  return res.status(statusCode).json({
    success: false,
    message,
    errors,
  });
};

/**
 * Send a paginated response
 * @param res Express response object
 * @param data Response data
 * @param page Current page
 * @param limit Items per page
 * @param total Total number of items
 * @param message Success message
 * @param statusCode HTTP status code
 * @param additionalMeta Additional metadata
 */
export const sendPaginated = <T>(
  res: Response,
  data: T,
  page: number,
  limit: number,
  total: number,
  message: string = 'Success',
  statusCode: number = 200,
  additionalMeta?: any
): Response<ApiResponse<T>> => {
  const pages = Math.ceil(total / limit);
  
  return res.status(statusCode).json({
    success: true,
    message,
    data,
    meta: {
      pagination: {
        page,
        limit,
        total,
        pages,
      },
      ...additionalMeta,
    },
  });
};
import { Request, Response, NextFunction } from 'express';
import { validationResult, ValidationChain } from 'express-validator';
import { sendError } from './apiResponse';

/**
 * Middleware to validate request using express-validator
 * @param validations Array of validation chains
 */
export const validate = (validations: ValidationChain[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Run all validations
    await Promise.all(validations.map(validation => validation.run(req)));

    // Check for validation errors
    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }

    // Format errors for response
    const formattedErrors = errors.array().map(error => ({
      field: error.param,
      message: error.msg,
      value: error.value,
    }));

    // Send error response
    return sendError(
      res,
      'Validation Error',
      400,
      formattedErrors
    );
  };
};

/**
 * Helper function to check if a string is a valid MongoDB ObjectId
 * @param id String to validate
 */
export const isValidObjectId = (id: string): boolean => {
  return /^[0-9a-fA-F]{24}$/.test(id);
};

/**
 * Helper function to validate email format
 * @param email Email to validate
 */
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

/**
 * Helper function to validate password strength
 * @param password Password to validate
 */
export const isStrongPassword = (password: string): boolean => {
  // At least 8 characters, one uppercase, one lowercase, one number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  return passwordRegex.test(password);
};

/**
 * Helper function to validate phone number format
 * @param phone Phone number to validate
 */
export const isValidPhone = (phone: string): boolean => {
  const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
  return phoneRegex.test(phone);
};

/**
 * Helper function to sanitize a string for use in a query
 * @param str String to sanitize
 */
export const sanitizeString = (str: string): string => {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};
interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  role: 'user' | 'admin';
  avatar?: string;
  address?: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  phone?: string;
  isVerified: boolean;
  resetPasswordToken?: string;
  resetPasswordExpire?: Date;
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}
import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcryptjs';

// Code for: export interface IUser extends Document {

const userSchema = new Schema<IUser>(
  {
    name: {
      type: String,
      required: [true, 'Please provide a name'],
      trim: true,
      maxlength: [50, 'Name cannot be more than 50 characters'],
    },
    email: {
      type: String,
      required: [true, 'Please provide an email'],
      unique: true,
      lowercase: true,
      trim: true,
      match: [
        /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
        'Please provide a valid email',
      ],
    },
    password: {
      type: String,
      required: [true, 'Please provide a password'],
      minlength: [6, 'Password must be at least 6 characters'],
      select: false, // Don't return password in queries
    },
    role: {
      type: String,
      enum: ['user', 'admin'],
      default: 'user',
    },
    avatar: {
      type: String,
    },
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String,
      country: String,
    },
    phone: {
      type: String,
      match: [/^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/, 'Please provide a valid phone number'],
    },
    isVerified: {
      type: Boolean,
      default: false,
    },
    resetPasswordToken: String,
    resetPasswordExpire: Date,
  },
  {
    timestamps: true,
  }
);

// Encrypt password before saving
userSchema.pre('save', async function (next) {
  // Only hash the password if it's modified (or new)
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error: any) {
    next(error);
  }
});

// Method to compare password
userSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export const User = mongoose.model<IUser>('User', userSchema);
interface IOrderItem {
  product: mongoose.Types.ObjectId;
  name: string;
  quantity: number;
  price: number;
  image: string;
}
interface IShippingAddress {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}
interface IOrder extends Document {
  user: mongoose.Types.ObjectId;
  orderItems: IOrderItem[];
  shippingAddress: IShippingAddress;
  paymentMethod: string;
  paymentResult?: {
    id: string;
    status: string;
    update_time: string;
    email_address: string;
  };
  itemsPrice: number;
  taxPrice: number;
  shippingPrice: number;
  totalPrice: number;
  isPaid: boolean;
  paidAt?: Date;
  isDelivered: boolean;
  deliveredAt?: Date;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled';
  trackingNumber?: string;
  createdAt: Date;
  updatedAt: Date;
}
import mongoose, { Document, Schema } from 'mongoose';

// Code for: export interface IOrderItem {

// Code for: export interface IShippingAddress {

// Code for: export interface IOrder extends Document {

const orderItemSchema = new Schema<IOrderItem>({
  product: {
    type: Schema.Types.ObjectId,
    ref: 'Product',
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: [1, 'Quantity must be at least 1'],
  },
  price: {
    type: Number,
    required: true,
    min: [0, 'Price cannot be negative'],
  },
  image: {
    type: String,
    required: true,
  },
});

const shippingAddressSchema = new Schema<IShippingAddress>({
  street: {
    type: String,
    required: [true, 'Street address is required'],
  },
  city: {
    type: String,
    required: [true, 'City is required'],
  },
  state: {
    type: String,
    required: [true, 'State is required'],
  },
  zipCode: {
    type: String,
    required: [true, 'Zip code is required'],
  },
  country: {
    type: String,
    required: [true, 'Country is required'],
  },
});

const orderSchema = new Schema<IOrder>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    orderItems: [orderItemSchema],
    shippingAddress: shippingAddressSchema,
    paymentMethod: {
      type: String,
      required: [true, 'Payment method is required'],
    },
    paymentResult: {
      id: String,
      status: String,
      update_time: String,
      email_address: String,
    },
    itemsPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    taxPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    shippingPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    totalPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    isPaid: {
      type: Boolean,
      default: false,
    },
    paidAt: Date,
    isDelivered: {
      type: Boolean,
      default: false,
    },
    deliveredAt: Date,
    status: {
      type: String,
      enum: ['pending', 'processing', 'shipped', 'delivered', 'cancelled'],
      default: 'pending',
    },
    trackingNumber: String,
  },
  {
    timestamps: true,
  }
);

// Virtual for order age in days
orderSchema.virtual('ageInDays').get(function () {
  return Math.floor(
    (Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24)
  );
});

// Index for faster queries
orderSchema.index({ user: 1, createdAt: -1 });
orderSchema.index({ status: 1 });

export const Order = mongoose.model<IOrder>('Order', orderSchema);
interface ICartItem {
  product: mongoose.Types.ObjectId;
  quantity: number;
  price: number;
  name: string;
  image: string;
}
interface ICart extends Document {
  user: mongoose.Types.ObjectId;
  items: ICartItem[];
  totalPrice: number;
  createdAt: Date;
  updatedAt: Date;
  calculateTotalPrice(): number;
}
import mongoose, { Document, Schema } from 'mongoose';

// Code for: export interface ICartItem {

// Code for: export interface ICart extends Document {

const cartItemSchema = new Schema<ICartItem>({
  product: {
    type: Schema.Types.ObjectId,
    ref: 'Product',
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: [1, 'Quantity must be at least 1'],
  },
  price: {
    type: Number,
    required: true,
    min: [0, 'Price cannot be negative'],
  },
  name: {
    type: String,
    required: true,
  },
  image: {
    type: String,
    required: true,
  },
});

const cartSchema = new Schema<ICart>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      unique: true,
    },
    items: [cartItemSchema],
    totalPrice: {
      type: Number,
      required: true,
      default: 0,
      min: 0,
    },
  },
  {
    timestamps: true,
  }
);

// Calculate total price before saving
cartSchema.pre('save', function (next) {
  this.totalPrice = this.calculateTotalPrice();
  next();
});

// Method to calculate total price
cartSchema.methods.calculateTotalPrice = function (): number {
  return this.items.reduce(
    (total, item) => total + item.price * item.quantity,
    0
  );
};

export const Cart = mongoose.model<ICart>('Cart', cartSchema);
interface IReview {
  user: mongoose.Types.ObjectId;
  name: string;
  rating: number;
  comment: string;
  date: Date;
}
interface IProduct extends Document {
  name: string;
  description: string;
  shortDescription: string;
  price: number;
  originalPrice?: number;
  images: string[];
  category: string;
  brand: string;
  stock: number;
  rating: number;
  numReviews: number;
  reviews: IReview[];
  sku: string;
  featured: boolean;
  isNew: boolean;
  onSale: boolean;
  tags: string[];
  attributes: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}
import mongoose, { Document, Schema } from 'mongoose';

// Code for: export interface IReview {

// Code for: export interface IProduct extends Document {

const reviewSchema = new Schema<IReview>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    name: {
      type: String,
      required: true,
    },
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
    comment: {
      type: String,
      required: true,
    },
    date: {
      type: Date,
      default: Date.now,
    },
  },
  { _id: true }
);

const productSchema = new Schema<IProduct>(
  {
    name: {
      type: String,
      required: [true, 'Please provide a product name'],
      trim: true,
      maxlength: [100, 'Product name cannot be more than 100 characters'],
    },
    description: {
      type: String,
      required: [true, 'Please provide a product description'],
    },
    shortDescription: {
      type: String,
      required: [true, 'Please provide a short description'],
      maxlength: [200, 'Short description cannot be more than 200 characters'],
    },
    price: {
      type: Number,
      required: [true, 'Please provide a product price'],
      min: [0, 'Price cannot be negative'],
    },
    originalPrice: {
      type: Number,
      min: [0, 'Original price cannot be negative'],
    },
    images: [
      {
        type: String,
        required: [true, 'Please provide at least one product image'],
      },
    ],
    category: {
      type: String,
      required: [true, 'Please provide a product category'],
      index: true,
    },
    brand: {
      type: String,
      required: [true, 'Please provide a product brand'],
      index: true,
    },
    stock: {
      type: Number,
      required: [true, 'Please provide product stock'],
      min: [0, 'Stock cannot be negative'],
      default: 0,
    },
    rating: {
      type: Number,
      default: 0,
      min: 0,
      max: 5,
    },
    numReviews: {
      type: Number,
      default: 0,
    },
    reviews: [reviewSchema],
    sku: {
      type: String,
      required: [true, 'Please provide a product SKU'],
      unique: true,
      trim: true,
    },
    featured: {
      type: Boolean,
      default: false,
    },
    isNew: {
      type: Boolean,
      default: false,
    },
    onSale: {
      type: Boolean,
      default: false,
    },
    tags: [
      {
        type: String,
        trim: true,
      },
    ],
    attributes: {
      type: Map,
      of: Schema.Types.Mixed,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Index for search
productSchema.index({ name: 'text', description: 'text', brand: 'text', category: 'text' });

// Calculate average rating when reviews are modified
productSchema.pre('save', function (next) {
  if (this.isModified('reviews')) {
    if (this.reviews.length === 0) {
      this.rating = 0;
      this.numReviews = 0;
    } else {
      this.rating =
        this.reviews.reduce((acc, review) => acc + review.rating, 0) /
        this.reviews.length;
      this.numReviews = this.reviews.length;
    }
  }
  next();
});

export const Product = mongoose.model<IProduct>('Product', productSchema);
interface ICategory extends Document {
  name: string;
  slug: string;
  description?: string;
  image?: string;
  parent?: mongoose.Types.ObjectId;
  level: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}
import mongoose, { Document, Schema } from 'mongoose';
import slugify from 'slugify';

// Code for: export interface ICategory extends Document {

const categorySchema = new Schema<ICategory>(
  {
    name: {
      type: String,
      required: [true, 'Category name is required'],
      trim: true,
      unique: true,
      maxlength: [50, 'Category name cannot be more than 50 characters'],
    },
    slug: {
      type: String,
      unique: true,
      lowercase: true,
      index: true,
    },
    description: {
      type: String,
      maxlength: [500, 'Description cannot be more than 500 characters'],
    },
    image: {
      type: String,
    },
    parent: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      default: null,
    },
    level: {
      type: Number,
      default: 1,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual for subcategories
categorySchema.virtual('subcategories', {
  ref: 'Category',
  localField: '_id',
  foreignField: 'parent',
});

// Generate slug before saving
categorySchema.pre('save', function (next) {
  if (this.isModified('name')) {
    this.slug = slugify(this.name, { lower: true });
  }
  
  // Set level based on parent
  if (this.parent) {
    this.level = 2; // For simplicity, we're using just 2 levels
  } else {
    this.level = 1;
  }
  
  next();
});

// Index for faster queries
categorySchema.index({ name: 'text', slug: 'text' });

export const Category = mongoose.model<ICategory>('Category', categorySchema);
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User, IUser } from '../models/user.model';

// Generate JWT token
const generateToken = (id: string): string => {
  return jwt.sign({ id }, process.env.JWT_SECRET || 'secret', {
    expiresIn: process.env.JWT_EXPIRES_IN || '30d',
  });
};

// @desc    Register a new user
// @route   POST /api/auth/register
// @access  Public
export const register = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { name, email, password } = req.body;

    // Check if user already exists
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({
        message: 'User already exists',
      });
    }

    // Create new user
    const user = await User.create({
      name,
      email,
      password,
    });

    // Generate token
    const token = generateToken(user._id.toString());

    res.status(201).json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
export const login = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { email, password } = req.body;

    // Check if email and password are provided
    if (!email || !password) {
      return res.status(400).json({
        message: 'Please provide email and password',
      });
    }

    // Find user by email and include password
    const user = await User.findOne({ email }).select('+password');

    // Check if user exists and password is correct
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({
        message: 'Invalid email or password',
      });
    }

    // Generate token
    const token = generateToken(user._id.toString());

    res.status(200).json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get current user profile
// @route   GET /api/auth/me
// @access  Private
export const getCurrentUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await User.findById(req.user._id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    res.status(200).json({
      id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      address: user.address,
      phone: user.phone,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Update user profile
// @route   PUT /api/auth/profile
// @access  Private
export const updateProfile = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { name, email, password, avatar, address, phone } = req.body;

    // Find user
    const user = await User.findById(req.user._id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // Update fields
    if (name) user.name = name;
    if (email) user.email = email;
    if (password) user.password = password;
    if (avatar) user.avatar = avatar;
    if (address) user.address = address;
    if (phone) user.phone = phone;

    // Save user
    await user.save();

    res.status(200).json({
      id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      address: user.address,
      phone: user.phone,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Forgot password
// @route   POST /api/auth/forgot-password
// @access  Public
export const forgotPassword = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { email } = req.body;

    // Find user by email
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // Generate reset token
    const resetToken = Math.random().toString(36).slice(2, 10);
    
    // Hash token and set to resetPasswordToken field
    user.resetPasswordToken = resetToken;
    
    // Set expire
    user.resetPasswordExpire = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    
    await user.save();

    // In a real app, send email with reset token
    // For this example, we'll just return the token
    res.status(200).json({
      message: 'Password reset email sent',
      resetToken, // In a real app, don't return this
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Reset password
// @route   POST /api/auth/reset-password/:token
// @access  Public
export const resetPassword = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { token } = req.params;
    const { password } = req.body;

    // Find user by reset token and check if it's expired
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpire: { $gt: Date.now() },
    });

    if (!user) {
      return res.status(400).json({
        message: 'Invalid or expired token',
      });
    }

    // Set new password
    user.password = password;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpire = undefined;
    
    await user.save();

    // Generate new token
    const newToken = generateToken(user._id.toString());

    res.status(200).json({
      message: 'Password reset successful',
      token: newToken,
    });
  } catch (error) {
    next(error);
  }
};
import { Request, Response, NextFunction } from 'express';
import { Order, IOrder } from '../models/order.model';
import { Product } from '../models/product.model';
import { Cart } from '../models/cart.model';

// @desc    Create new order
// @route   POST /api/orders
// @access  Private
export const createOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const {
      orderItems,
      shippingAddress,
      paymentMethod,
    } = req.body;

    if (!orderItems || orderItems.length === 0) {
      return res.status(400).json({
        message: 'No order items',
      });
    }

    // Verify all products exist and have sufficient stock
    for (const item of orderItems) {
      const product = await Product.findById(item.product);
      
      if (!product) {
        return res.status(404).json({
          message: `Product not found: ${item.product}`,
        });
      }
      
      if (product.stock < item.quantity) {
        return res.status(400).json({
          message: `Not enough stock for ${product.name}. Available: ${product.stock}`,
        });
      }
    }

    // Calculate prices
    const itemsPrice = orderItems.reduce(
      (acc, item) => acc + item.price * item.quantity,
      0
    );
    
    // Apply tax (example: 10%)
    const taxRate = 0.1;
    const taxPrice = itemsPrice * taxRate;
    
    // Calculate shipping (example: free shipping over $100, otherwise $10)
    const shippingPrice = itemsPrice > 100 ? 0 : 10;
    
    // Total price
    const totalPrice = itemsPrice + taxPrice + shippingPrice;

    // Create order
    const order = await Order.create({
      user: req.user._id,
      orderItems,
      shippingAddress,
      paymentMethod,
      itemsPrice,
      taxPrice,
      shippingPrice,
      totalPrice,
    });

    // Update product stock
    for (const item of orderItems) {
      const product = await Product.findById(item.product);
      if (product) {
        product.stock -= item.quantity;
        await product.save();
      }
    }

    // Clear user's cart
    await Cart.findOneAndUpdate(
      { user: req.user._id },
      { $set: { items: [], totalPrice: 0 } }
    );

    res.status(201).json(order);
  } catch (error) {
    next(error);
  }
};

// @desc    Get order by ID
// @route   GET /api/orders/:id
// @access  Private
export const getOrderById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Check if the order belongs to the user or if the user is an admin
    if (
      order.user.toString() !== req.user._id.toString() &&
      req.user.role !== 'admin'
    ) {
      return res.status(403).json({
        message: 'Not authorized to access this order',
      });
    }

    res.status(200).json(order);
  } catch (error) {
    next(error);
  }
};

// @desc    Update order to paid
// @route   PUT /api/orders/:id/pay
// @access  Private
export const updateOrderToPaid = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Update order
    order.isPaid = true;
    order.paidAt = new Date();
    order.status = 'processing';
    order.paymentResult = {
      id: req.body.id,
      status: req.body.status,
      update_time: req.body.update_time,
      email_address: req.body.email_address,
    };

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

// @desc    Update order to delivered
// @route   PUT /api/orders/:id/deliver
// @access  Private/Admin
export const updateOrderToDelivered = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Update order
    order.isDelivered = true;
    order.deliveredAt = new Date();
    order.status = 'delivered';
    order.trackingNumber = req.body.trackingNumber || order.trackingNumber;

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

// @desc    Update order status
// @route   PUT /api/orders/:id/status
// @access  Private/Admin
export const updateOrderStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { status, trackingNumber } = req.body;

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Update order status
    order.status = status;
    
    // If status is shipped, update tracking number
    if (status === 'shipped' && trackingNumber) {
      order.trackingNumber = trackingNumber;
    }
    
    // If status is delivered, update delivered status
    if (status === 'delivered') {
      order.isDelivered = true;
      order.deliveredAt = new Date();
    }

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

// @desc    Get logged in user orders
// @route   GET /api/orders/myorders
// @access  Private
export const getMyOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const orders = await Order.find({ user: req.user._id }).sort({
      createdAt: -1,
    });

    res.status(200).json(orders);
  } catch (error) {
    next(error);
  }
};

// @desc    Get all orders
// @route   GET /api/orders
// @access  Private/Admin
export const getOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { 
      status, 
      page = 1, 
      limit = 10,
      sort = 'createdAt',
      order = 'desc'
    } = req.query;

    // Build filter
    const filter: any = {};
    if (status) {
      filter.status = status;
    }

    // Build sort
    const sortOption: any = {};
    sortOption[sort as string] = order === 'desc' ? -1 : 1;

    // Calculate pagination
    const pageNum = Number(page);
    const limitNum = Number(limit);
    const skip = (pageNum - 1) * limitNum;

    // Get orders
    const orders = await Order.find(filter)
      .populate('user', 'id name email')
      .sort(sortOption)
      .skip(skip)
      .limit(limitNum);

    // Get total count
    const total = await Order.countDocuments(filter);

    res.status(200).json({
      orders,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      total,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Cancel order
// @route   PUT /api/orders/:id/cancel
// @access  Private
export const cancelOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Check if the order belongs to the user or if the user is an admin
    if (
      order.user.toString() !== req.user._id.toString() &&
      req.user.role !== 'admin'
    ) {
      return res.status(403).json({
        message: 'Not authorized to cancel this order',
      });
    }

    // Check if order can be cancelled
    if (order.status === 'delivered' || order.status === 'shipped') {
      return res.status(400).json({
        message: 'Cannot cancel an order that has been shipped or delivered',
      });
    }

    // Update order status
    order.status = 'cancelled';

    // Restore product stock
    for (const item of order.orderItems) {
      const product = await Product.findById(item.product);
      if (product) {
        product.stock += item.quantity;
        await product.save();
      }
    }

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};
import { Request, Response, NextFunction } from 'express';
import { User, IUser } from '../models/user.model';

// @desc    Get all users
// @route   GET /api/users
// @access  Private/Admin
export const getUsers = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { 
      page = 1, 
      limit = 10,
      sort = 'createdAt',
      order = 'desc',
      search
    } = req.query;

    // Build filter
    const filter: any = {};
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
      ];
    }

    // Build sort
    const sortOption: any = {};
    sortOption[sort as string] = order === 'desc' ? -1 : 1;

    // Calculate pagination
    const pageNum = Number(page);
    const limitNum = Number(limit);
    const skip = (pageNum - 1) * limitNum;

    // Get users
    const users = await User.find(filter)
      .select('-password')
      .sort(sortOption)
      .skip(skip)
      .limit(limitNum);

    // Get total count
    const total = await User.countDocuments(filter);

    res.status(200).json({
      users,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      total,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get user by ID
// @route   GET /api/users/:id
// @access  Private/Admin
export const getUserById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id).select('-password');

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    res.status(200).json(user);
  } catch (error) {
    next(error);
  }
};

// @desc    Update user
// @route   PUT /api/users/:id
// @access  Private/Admin
export const updateUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    const { name, email, role, isVerified } = req.body;

    // Update fields
    if (name) user.name = name;
    if (email) user.email = email;
    if (role) user.role = role;
    if (isVerified !== undefined) user.isVerified = isVerified;

    const updatedUser = await user.save();

    res.status(200).json({
      id: updatedUser._id,
      name: updatedUser.name,
      email: updatedUser.email,
      role: updatedUser.role,
      isVerified: updatedUser.isVerified,
      createdAt: updatedUser.createdAt,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Delete user
// @route   DELETE /api/users/:id
// @access  Private/Admin
export const deleteUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // Prevent admin from deleting themselves
    if (user._id.toString() === req.user._id.toString()) {
      return res.status(400).json({
        message: 'Cannot delete your own account',
      });
    }

    await user.deleteOne();

    res.status(200).json({ message: 'User removed' });
  } catch (error) {
    next(error);
  }
};

// @desc    Get user orders
// @route   GET /api/users/:id/orders
// @access  Private/Admin
export const getUserOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // This would typically use a model import, but for simplicity we'll use a direct import
    const Order = require('../models/order.model').Order;
    
    const orders = await Order.find({ user: req.params.id }).sort({
      createdAt: -1,
    });

    res.status(200).json(orders);
  } catch (error) {
    next(error);
  }
};
import { Request, Response, NextFunction } from 'express';
import { Category, ICategory } from '../models/category.model';

// @desc    Get all categories
// @route   GET /api/categories
// @access  Public
export const getCategories = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { parent, level } = req.query;
    
    // Build filter
    const filter: any = {};
    if (parent) {
      filter.parent = parent;
    } else if (parent === 'null') {
      filter.parent = null;
    }
    
    if (level) {
      filter.level = Number(level);
    }

    const categories = await Category.find(filter).sort({ name: 1 });

    res.status(200).json(categories);
  } catch (error) {
    next(error);
  }
};

// @desc    Get category by ID
// @route   GET /api/categories/:id
// @access  Public
export const getCategoryById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const category = await Category.findById(req.params.id);

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    res.status(200).json(category);
  } catch (error) {
    next(error);
  }
};

// @desc    Get category by slug
// @route   GET /api/categories/slug/:slug
// @access  Public
export const getCategoryBySlug = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const category = await Category.findOne({ slug: req.params.slug });

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    res.status(200).json(category);
  } catch (error) {
    next(error);
  }
};

// @desc    Create a category
// @route   POST /api/categories
// @access  Private/Admin
export const createCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { name, description, image, parent } = req.body;

    // Check if category with same name exists
    const existingCategory = await Category.findOne({ name });
    if (existingCategory) {
      return res.status(400).json({
        message: 'Category with this name already exists',
      });
    }

    // Create category
    const category = await Category.create({
      name,
      description,
      image,
      parent,
    });

    res.status(201).json(category);
  } catch (error) {
    next(error);
  }
};

// @desc    Update a category
// @route   PUT /api/categories/:id
// @access  Private/Admin
export const updateCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const category = await Category.findById(req.params.id);

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    const { name, description, image, parent, isActive } = req.body;

    // If name is changed, check if it already exists
    if (name && name !== category.name) {
      const existingCategory = await Category.findOne({ name });
      if (existingCategory) {
        return res.status(400).json({
          message: 'Category with this name already exists',
        });
      }
    }

    // Update category fields
    if (name) category.name = name;
    if (description !== undefined) category.description = description;
    if (image !== undefined) category.image = image;
    if (parent !== undefined) category.parent = parent;
    if (isActive !== undefined) category.isActive = isActive;

    const updatedCategory = await category.save();

    res.status(200).json(updatedCategory);
  } catch (error) {
    next(error);
  }
};

// @desc    Delete a category
// @route   DELETE /api/categories/:id
// @access  Private/Admin
export const deleteCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const category = await Category.findById(req.params.id);

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    // Check if category has subcategories
    const hasSubcategories = await Category.exists({ parent: category._id });
    if (hasSubcategories) {
      return res.status(400).json({
        message: 'Cannot delete category with subcategories',
      });
    }

    // Check if category has products
    const Product = require('../models/product.model').Product;
    const hasProducts = await Product.exists({ category: category.name });
    if (hasProducts) {
      return res.status(400).json({
        message: 'Cannot delete category with products',
      });
    }

    await category.deleteOne();

    res.status(200).json({ message: 'Category removed' });
  } catch (error) {
    next(error);
  }
};

// @desc    Get category tree
// @route   GET /api/categories/tree
// @access  Public
export const getCategoryTree = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get all parent categories
    const parentCategories = await Category.find({ parent: null }).sort({ name: 1 });
    
    // For each parent category, get its subcategories
    const categoryTree = await Promise.all(
      parentCategories.map(async (parent) => {
        const subcategories = await Category.find({ parent: parent._id }).sort({ name: 1 });
        
        return {
          _id: parent._id,
          name: parent.name,
          slug: parent.slug,
          description: parent.description,
          image: parent.image,
          level: parent.level,
          isActive: parent.isActive,
          subcategories: subcategories.map((sub) => ({
            _id: sub._id,
            name: sub.name,
            slug: sub.slug,
            description: sub.description,
            image: sub.image,
            level: sub.level,
            isActive: sub.isActive,
          })),
        };
      })
    );
    
    res.status(200).json(categoryTree);
  } catch (error) {
    next(error);
  }
};
import { Request, Response, NextFunction } from 'express';
import { Cart, ICart } from '../models/cart.model';
import { Product } from '../models/product.model';

// @desc    Get user cart
// @route   GET /api/cart
// @access  Private
export const getCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    let cart = await Cart.findOne({ user: req.user._id });

    if (!cart) {
      // Create empty cart if none exists
      cart = await Cart.create({
        user: req.user._id,
        items: [],
        totalPrice: 0,
      });
    }

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Add item to cart
// @route   POST /api/cart/items
// @access  Private
export const addToCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { productId, quantity = 1 } = req.body;

    // Validate product exists
    const product = await Product.findById(productId);
    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Check if product is in stock
    if (product.stock < quantity) {
      return res.status(400).json({
        message: `Not enough stock. Available: ${product.stock}`,
      });
    }

    // Get or create cart
    let cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      cart = await Cart.create({
        user: req.user._id,
        items: [],
        totalPrice: 0,
      });
    }

    // Check if product already in cart
    const existingItemIndex = cart.items.findIndex(
      (item) => item.product.toString() === productId
    );

    if (existingItemIndex !== -1) {
      // Update quantity if product already in cart
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item to cart
      cart.items.push({
        product: product._id,
        name: product.name,
        quantity,
        price: product.price,
        image: product.images[0],
      });
    }

    // Calculate total price
    cart.totalPrice = cart.calculateTotalPrice();

    // Save cart
    await cart.save();

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Update cart item quantity
// @route   PUT /api/cart/items/:productId
// @access  Private
export const updateCartItem = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { productId } = req.params;
    const { quantity } = req.body;

    if (quantity < 1) {
      return res.status(400).json({
        message: 'Quantity must be at least 1',
      });
    }

    // Validate product exists
    const product = await Product.findById(productId);
    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Check if product is in stock
    if (product.stock < quantity) {
      return res.status(400).json({
        message: `Not enough stock. Available: ${product.stock}`,
      });
    }

    // Get cart
    const cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      return res.status(404).json({
        message: 'Cart not found',
      });
    }

    // Find item in cart
    const itemIndex = cart.items.findIndex(
      (item) => item.product.toString() === productId
    );

    if (itemIndex === -1) {
      return res.status(404).json({
        message: 'Item not found in cart',
      });
    }

    // Update quantity
    cart.items[itemIndex].quantity = quantity;

    // Calculate total price
    cart.totalPrice = cart.calculateTotalPrice();

    // Save cart
    await cart.save();

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Remove item from cart
// @route   DELETE /api/cart/items/:productId
// @access  Private
export const removeFromCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { productId } = req.params;

    // Get cart
    const cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      return res.status(404).json({
        message: 'Cart not found',
      });
    }

    // Remove item from cart
    cart.items = cart.items.filter(
      (item) => item.product.toString() !== productId
    );

    // Calculate total price
    cart.totalPrice = cart.calculateTotalPrice();

    // Save cart
    await cart.save();

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Clear cart
// @route   DELETE /api/cart
// @access  Private
export const clearCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get cart
    const cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      return res.status(404).json({
        message: 'Cart not found',
      });
    }

    // Clear cart
    cart.items = [];
    cart.totalPrice = 0;

    // Save cart
    await cart.save();

    res.status(200).json({ message: 'Cart cleared' });
  } catch (error) {
    next(error);
  }
};
import { Request, Response, NextFunction } from 'express';
import { Product, IProduct } from '../models/product.model';
import { User } from '../models/user.model';

// @desc    Get all products
// @route   GET /api/products
// @access  Public
export const getProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { 
      category, 
      brand, 
      search, 
      sort, 
      min, 
      max, 
      page = 1, 
      limit = 10,
      featured,
      isNew,
      onSale
    } = req.query;

    // Build filter object
    const filter: any = {};
    
    if (category) {
      filter.category = category;
    }
    
    if (brand) {
      filter.brand = brand;
    }
    
    if (search) {
      filter.$text = { $search: search as string };
    }
    
    if (min || max) {
      filter.price = {};
      if (min) filter.price.$gte = Number(min);
      if (max) filter.price.$lte = Number(max);
    }

    if (featured === 'true') {
      filter.featured = true;
    }

    if (isNew === 'true') {
      filter.isNew = true;
    }

    if (onSale === 'true') {
      filter.onSale = true;
    }

    // Build sort object
    let sortOption = {};
    if (sort) {
      switch (sort) {
        case 'price':
          sortOption = { price: 1 };
          break;
        case 'price-desc':
          sortOption = { price: -1 };
          break;
        case 'name':
          sortOption = { name: 1 };
          break;
        case 'name-desc':
          sortOption = { name: -1 };
          break;
        case 'newest':
          sortOption = { createdAt: -1 };
          break;
        case 'rating':
          sortOption = { rating: -1 };
          break;
        default:
          sortOption = { createdAt: -1 };
      }
    } else {
      sortOption = { createdAt: -1 };
    }

    // Calculate pagination
    const pageNum = Number(page);
    const limitNum = Number(limit);
    const skip = (pageNum - 1) * limitNum;

    // Execute query
    const products = await Product.find(filter)
      .sort(sortOption)
      .skip(skip)
      .limit(limitNum);

    // Get total count for pagination
    const total = await Product.countDocuments(filter);

    res.status(200).json({
      products,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      total,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get product by ID
// @route   GET /api/products/:id
// @access  Public
export const getProductById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    res.status(200).json(product);
  } catch (error) {
    next(error);
  }
};

// @desc    Create a product
// @route   POST /api/products
// @access  Private/Admin
export const createProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const {
      name,
      description,
      shortDescription,
      price,
      originalPrice,
      images,
      category,
      brand,
      stock,
      sku,
      featured,
      isNew,
      onSale,
      tags,
      attributes,
    } = req.body;

    // Check if product with same SKU exists
    const existingProduct = await Product.findOne({ sku });
    if (existingProduct) {
      return res.status(400).json({
        message: 'Product with this SKU already exists',
      });
    }

    // Create product
    const product = await Product.create({
      name,
      description,
      shortDescription,
      price,
      originalPrice,
      images,
      category,
      brand,
      stock,
      sku,
      featured: featured || false,
      isNew: isNew || false,
      onSale: onSale || false,
      tags: tags || [],
      attributes: attributes || {},
      rating: 0,
      numReviews: 0,
      reviews: [],
    });

    res.status(201).json(product);
  } catch (error) {
    next(error);
  }
};

// @desc    Update a product
// @route   PUT /api/products/:id
// @access  Private/Admin
export const updateProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Update product fields
    const updatedProduct = await Product.findByIdAndUpdate(
      req.params.id,
      { $set: req.body },
      { new: true, runValidators: true }
    );

    res.status(200).json(updatedProduct);
  } catch (error) {
    next(error);
  }
};

// @desc    Delete a product
// @route   DELETE /api/products/:id
// @access  Private/Admin
export const deleteProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    await product.deleteOne();

    res.status(200).json({ message: 'Product removed' });
  } catch (error) {
    next(error);
  }
};

// @desc    Create new review
// @route   POST /api/products/:id/reviews
// @access  Private
export const createProductReview = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { rating, comment } = req.body;

    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Check if user already reviewed this product
    const alreadyReviewed = product.reviews.find(
      (r) => r.user.toString() === req.user._id.toString()
    );

    if (alreadyReviewed) {
      return res.status(400).json({
        message: 'Product already reviewed',
      });
    }

    // Create review
    const review = {
      user: req.user._id,
      name: req.user.name,
      rating: Number(rating),
      comment,
      date: new Date(),
    };

    // Add review to product
    product.reviews.push(review);
    
    // Update product rating
    product.numReviews = product.reviews.length;
    product.rating =
      product.reviews.reduce((acc, item) => item.rating + acc, 0) /
      product.reviews.length;

    await product.save();

    res.status(201).json({ message: 'Review added' });
  } catch (error) {
    next(error);
  }
};

// @desc    Get top rated products
// @route   GET /api/products/top
// @access  Public
export const getTopProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const limit = Number(req.query.limit) || 5;
    
    const products = await Product.find({})
      .sort({ rating: -1 })
      .limit(limit);

    res.status(200).json(products);
  } catch (error) {
    next(error);
  }
};

// @desc    Get related products
// @route   GET /api/products/:id/related
// @access  Public
export const getRelatedProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    const limit = Number(req.query.limit) || 4;

    // Find products in the same category, excluding the current product
    const relatedProducts = await Product.find({
      _id: { $ne: product._id },
      category: product.category,
    })
      .limit(limit);

    res.status(200).json(relatedProducts);
  } catch (error) {
    next(error);
  }
};
import express from 'express';
import {
  getUsers,
  getUserById,
  updateUser,
  deleteUser,
  getUserOrders,
} from '../controllers/user.controller';
import { authMiddleware, adminMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// All routes are protected and admin-only
router.use(authMiddleware, adminMiddleware);

router.get('/', getUsers);
router.get('/:id', getUserById);
router.put('/:id', updateUser);
router.delete('/:id', deleteUser);
router.get('/:id/orders', getUserOrders);

export default router;
import express from 'express';
import {
  getProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct,
  createProductReview,
  getTopProducts,
  getRelatedProducts,
} from '../controllers/product.controller';
import { authMiddleware, adminMiddleware, optionalAuthMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Public routes
router.get('/', optionalAuthMiddleware, getProducts);
router.get('/top', getTopProducts);
router.get('/:id', getProductById);
router.get('/:id/related', getRelatedProducts);

// Protected routes
router.post('/:id/reviews', authMiddleware, createProductReview);

// Admin routes
router.post('/', authMiddleware, adminMiddleware, createProduct);
router.put('/:id', authMiddleware, adminMiddleware, updateProduct);
router.delete('/:id', authMiddleware, adminMiddleware, deleteProduct);

export default router;
import express from 'express';
import {
  getCategories,
  getCategoryById,
  getCategoryBySlug,
  createCategory,
  updateCategory,
  deleteCategory,
  getCategoryTree,
} from '../controllers/category.controller';
import { authMiddleware, adminMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Public routes
router.get('/', getCategories);
router.get('/tree', getCategoryTree);
router.get('/slug/:slug', getCategoryBySlug);
router.get('/:id', getCategoryById);

// Admin routes
router.post('/', authMiddleware, adminMiddleware, createCategory);
router.put('/:id', authMiddleware, adminMiddleware, updateCategory);
router.delete('/:id', authMiddleware, adminMiddleware, deleteCategory);

export default router;
import express from 'express';
import {
  createOrder,
  getOrderById,
  updateOrderToPaid,
  updateOrderToDelivered,
  updateOrderStatus,
  getMyOrders,
  getOrders,
  cancelOrder,
} from '../controllers/order.controller';
import { authMiddleware, adminMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Protected routes
router.post('/', authMiddleware, createOrder);
router.get('/myorders', authMiddleware, getMyOrders);
router.get('/:id', authMiddleware, getOrderById);
router.put('/:id/pay', authMiddleware, updateOrderToPaid);
router.put('/:id/cancel', authMiddleware, cancelOrder);

// Admin routes
router.get('/', authMiddleware, adminMiddleware, getOrders);
router.put('/:id/deliver', authMiddleware, adminMiddleware, updateOrderToDelivered);
router.put('/:id/status', authMiddleware, adminMiddleware, updateOrderStatus);

export default router;
import express from 'express';
import {
  getCart,
  addToCart,
  updateCartItem,
  removeFromCart,
  clearCart,
} from '../controllers/cart.controller';
import { authMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// All routes are protected
router.get('/', authMiddleware, getCart);
router.post('/items', authMiddleware, addToCart);
router.put('/items/:productId', authMiddleware, updateCartItem);
router.delete('/items/:productId', authMiddleware, removeFromCart);
router.delete('/', authMiddleware, clearCart);

export default router;
import express from 'express';
import {
  register,
  login,
  getCurrentUser,
  updateProfile,
  forgotPassword,
  resetPassword,
} from '../controllers/auth.controller';
import { authMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Public routes
router.post('/register', register);
router.post('/login', login);
router.post('/forgot-password', forgotPassword);
router.post('/reset-password/:token', resetPassword);

// Protected routes
router.get('/me', authMiddleware, getCurrentUser);
router.put('/profile', authMiddleware, updateProfile);

export default router;
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { theme } from './theme';
import { Layout } from './components/Layout';
import { HomePage } from './pages/HomePage';
import { ProductPage } from './pages/ProductPage';
import { CartPage } from './pages/CartPage';
import { CheckoutPage } from './pages/CheckoutPage';
import { LoginPage } from './pages/LoginPage';
import { RegisterPage } from './pages/RegisterPage';
import { ProfilePage } from './pages/ProfilePage';
import { OrdersPage } from './pages/OrdersPage';
import { AdminPage } from './pages/admin/AdminPage';
import { ProtectedRoute } from './components/ProtectedRoute';
import { AdminRoute } from './components/AdminRoute';
import { AuthProvider } from './contexts/AuthContext';
import { CartProvider } from './contexts/CartContext';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <AuthProvider>
          <CartProvider>
            <Router>
              <Layout>
                <Routes>
                  <Route path="/" element={<HomePage />} />
                  <Route path="/products/:id" element={<ProductPage />} />
                  <Route path="/cart" element={<CartPage />} />
                  <Route
                    path="/checkout"
                    element={
                      <ProtectedRoute>
                        <CheckoutPage />
                      </ProtectedRoute>
                    }
                  />
                  <Route path="/login" element={<LoginPage />} />
                  <Route path="/register" element={<RegisterPage />} />
                  <Route
                    path="/profile"
                    element={
                      <ProtectedRoute>
                        <ProfilePage />
                      </ProtectedRoute>
                    }
                  />
                  <Route
                    path="/orders"
                    element={
                      <ProtectedRoute>
                        <OrdersPage />
                      </ProtectedRoute>
                    }
                  />
                  <Route
                    path="/admin/*"
                    element={
                      <AdminRoute>
                        <AdminPage />
                      </AdminRoute>
                    }
                  />
                  <Route path="*" element={<div>Not Found</div>} />
                </Routes>
              </Layout>
            </Router>
          </CartProvider>
        </AuthProvider>
      </ThemeProvider>
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  );
}

export default App;

import React, { createContext, useContext, useEffect, useState } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { cartApi, CartItem } from '../services/api';
import { useAuth } from './AuthContext';

type CartContextType = {
  items: CartItem[];
  itemCount: number;
  total: number;
  isLoading: boolean;
  addToCart: (productId: string, quantity?: number) => Promise<void>;
  updateQuantity: (productId: string, quantity: number) => Promise<void>;
  removeFromCart: (productId: string) => Promise<void>;
  clearCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export const CartProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const queryClient = useQueryClient();
  const [localCart, setLocalCart] = useState<Record<string, number>>({});

  // Fetch cart from server if authenticated
  const { data: serverCart = [], isLoading } = useQuery<CartItem[]>(
    'cart',
    cartApi.getCart,
    {
      enabled: isAuthenticated,
      staleTime: 1000 * 60 * 5, // 5 minutes
      onError: (error) => {
        console.error('Failed to fetch cart', error);
      },
    }
  );

  // Sync local cart with server on auth state change
  useEffect(() => {
    if (isAuthenticated) {
      // If we have items in local cart and user logs in, sync with server
      if (Object.keys(localCart).length > 0) {
        const syncCart = async () => {
          try {
            await Promise.all(
              Object.entries(localCart).map(([productId, quantity]) =>
                cartApi.addToCart(productId, quantity)
              )
            );
            setLocalCart({});
            queryClient.invalidateQueries('cart');
          } catch (error) {
            console.error('Failed to sync cart', error);
          }
        };
        syncCart();
      } else {
        // Otherwise just refresh the cart
        queryClient.invalidateQueries('cart');
      }
    }
  }, [isAuthenticated]);

  // Add to cart mutation
  const addToCartMutation = useMutation(
    ({ productId, quantity = 1 }: { productId: string; quantity?: number }) =>
      isAuthenticated
        ? cartApi.addToCart(productId, quantity)
        : Promise.resolve(),
    {
      onMutate: async ({ productId, quantity = 1 }) => {
        if (!isAuthenticated) {
          // Update local cart for unauthenticated users
          setLocalCart((prev) => ({
            ...prev,
            [productId]: (prev[productId] || 0) + quantity,
          }));
          return;
        }
        
        // Optimistic update for authenticated users
        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        const existingItem = previousCart.find((item) => item.id === productId);
        
        if (existingItem) {
          const updatedCart = previousCart.map((item) =>
            item.id === productId
              ? { ...item, quantity: item.quantity + quantity }
              : item
          );
          queryClient.setQueryData('cart', updatedCart);
        } else {
          // In a real app, we would fetch the product details here
          const newItem: CartItem = {
            id: productId,
            name: `Product ${productId}`,
            price: 0,
            quantity,
            description: '',
            imageUrl: '',
            category: '',
            stock: 0,
            rating: 0,
            reviews: [],
          };
          queryClient.setQueryData('cart', [...previousCart, newItem]);
        }
        
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to add to cart', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Update quantity mutation
  const updateQuantityMutation = useMutation(
    ({ productId, quantity }: { productId: string; quantity: number }) =>
      isAuthenticated
        ? cartApi.updateCartItem(productId, quantity)
        : Promise.resolve(),
    {
      onMutate: async ({ productId, quantity }) => {
        if (!isAuthenticated) {
          setLocalCart((prev) => ({
            ...prev,
            [productId]: quantity,
          }));
          return;
        }

        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        const updatedCart = previousCart.map((item) =>
          item.id === productId ? { ...item, quantity } : item
        );
        
        queryClient.setQueryData('cart', updatedCart);
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to update quantity', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Remove from cart mutation
  const removeFromCartMutation = useMutation(
    (productId: string) =>
      isAuthenticated
        ? cartApi.removeFromCart(productId)
        : Promise.resolve(),
    {
      onMutate: async (productId) => {
        if (!isAuthenticated) {
          setLocalCart((prev) => {
            const newCart = { ...prev };
            delete newCart[productId];
            return newCart;
          });
          return;
        }

        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        const updatedCart = previousCart.filter((item) => item.id !== productId);
        queryClient.setQueryData('cart', updatedCart);
        
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to remove from cart', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Clear cart mutation
  const clearCartMutation = useMutation(
    () => (isAuthenticated ? cartApi.clearCart() : Promise.resolve()),
    {
      onMutate: async () => {
        if (!isAuthenticated) {
          setLocalCart({});
          return;
        }

        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        queryClient.setQueryData('cart', []);
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to clear cart', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Combine server cart with local cart for unauthenticated users
  const items = isAuthenticated
    ? serverCart
    : Object.entries(localCart).map(([id, quantity]) => ({
        id,
        name: `Product ${id}`,
        price: 0,
        quantity,
        description: '',
        imageUrl: '',
        category: '',
        stock: 0,
        rating: 0,
        reviews: [],
      }));

  const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);
  const total = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  const value = {
    items,
    itemCount,
    total,
    isLoading,
    addToCart: (productId: string, quantity = 1) =>
      addToCartMutation.mutateAsync({ productId, quantity }),
    updateQuantity: (productId: string, quantity: number) =>
      updateQuantityMutation.mutateAsync({ productId, quantity }),
    removeFromCart: (productId: string) =>
      removeFromCartMutation.mutateAsync(productId),
    clearCart: () => clearCartMutation.mutateAsync(),
  };

  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

import React, { createContext, useContext, useEffect, useState } from 'react';
import { useQuery, useQueryClient } from 'react-query';
import { authApi, User } from '../services/api';
import { useNavigate } from 'react-router-dom';

type AuthContextType = {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (name: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  updateUser: (updates: Partial<User>) => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isLoading, setIsLoading] = useState(true);
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  const { data: user, isLoading: isUserLoading } = useQuery<User | null>(
    'currentUser',
    async () => {
      try {
        const token = localStorage.getItem('token');
        if (!token) return null;
        return await authApi.getCurrentUser();
      } catch (error) {
        console.error('Failed to fetch current user', error);
        localStorage.removeItem('token');
        return null;
      }
    },
    {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
    }
  );

  useEffect(() => {
    if (localStorage.getItem('token') && !user && !isUserLoading) {
      queryClient.invalidateQueries('currentUser');
    } else {
      setIsLoading(false);
    }
  }, [user, isUserLoading, queryClient]);

  const login = async (email: string, password: string) => {
    try {
      const { token, user } = await authApi.login({ email, password });
      localStorage.setItem('token', token);
      queryClient.setQueryData('currentUser', user);
      navigate('/');
    } catch (error) {
      console.error('Login failed', error);
      throw error;
    }
  };

  const register = async (name: string, email: string, password: string) => {
    try {
      const { token, user } = await authApi.register({ name, email, password });
      localStorage.setItem('token', token);
      queryClient.setQueryData('currentUser', user);
      navigate('/');
    } catch (error) {
      console.error('Registration failed', error);
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    queryClient.setQueryData('currentUser', null);
    queryClient.clear();
    navigate('/login');
  };

  const updateUser = async (updates: Partial<User>) => {
    if (!user) return;
    try {
      const updatedUser = await authApi.updateProfile(updates);
      queryClient.setQueryData('currentUser', updatedUser);
    } catch (error) {
      console.error('Failed to update user', error);
      throw error;
    }
  };

  const value = {
    user: user || null,
    isLoading: isLoading || isUserLoading,
    isAuthenticated: !!user,
    login,
    register,
    logout,
    updateUser,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { CircularProgress, Box } from '@mui/material';

type ProtectedRouteProps = {
  children: React.ReactNode;
  adminOnly?: boolean;
};

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  adminOnly = false 
}) => {
  const { user, isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="60vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to when they were redirected. This allows us to send them
    // along to that page after they log in, which is a nicer user experience
    // than dropping them off on the home page.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (adminOnly && !user?.isAdmin) {
    // User is not an admin but trying to access an admin route
    return <Navigate to="/unauthorized" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export const AdminRoute: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  return <ProtectedRoute adminOnly>{children}</ProtectedRoute>;
};

import React, { useState } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Badge,
  Box,
  Container,
  useMediaQuery,
  useTheme,
  Avatar,
  Menu,
  MenuItem,
  Tooltip,
} from '@mui/material';
import {
  Menu as MenuIcon,
  ShoppingCart,
  Home,
  Category,
  Person,
  ExitToApp,
  ShoppingBag,
  AdminPanelSettings,
  Search,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useAuth } from '../contexts/AuthContext';
import { useCart } from '../contexts/CartContext';

const StyledAppBar = styled(AppBar)(({ theme }) => ({
  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
  backgroundColor: theme.palette.background.paper,
  color: theme.palette.text.primary,
}));

const StyledToolbar = styled(Toolbar)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  padding: theme.spacing(0, 2),
  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(0, 4),
  },
}));

const NavItems = styled('div')(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  gap: theme.spacing(2),
}));

const DrawerContainer = styled('div')(({ theme }) => ({
  width: 250,
  padding: theme.spacing(2, 0),
}));

const MainContent = styled('main')(({ theme }) => ({
  flexGrow: 1,
  padding: theme.spacing(3, 0),
  minHeight: `calc(100vh - ${theme.mixins.toolbar.minHeight}px - 64px)`,
  [theme.breakpoints.up('sm')]: {
    padding: theme.spacing(4, 0),
  },
}));

const Footer = styled('footer')(({ theme }) => ({
  backgroundColor: theme.palette.background.paper,
  padding: theme.spacing(3, 0),
  marginTop: 'auto',
  borderTop: `1px solid ${theme.palette.divider}`,
}));

const SearchContainer = styled('div')(({ theme }) => ({
  position: 'relative',
  borderRadius: theme.shape.borderRadius,
  backgroundColor: theme.palette.action.hover,
  marginRight: theme.spacing(2),
  marginLeft: 0,
  width: '100%',
  [theme.breakpoints.up('sm')]: {
    marginLeft: theme.spacing(3),
    width: 'auto',
  },
}));

const SearchIconWrapper = styled('div')(({ theme }) => ({
  padding: theme.spacing(0, 2),
  height: '100%',
  position: 'absolute',
  pointerEvents: 'none',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
}));

const SearchInput = styled('input')(({ theme }) => ({
  color: 'inherit',
  padding: theme.spacing(1, 1, 1, 0),
  paddingLeft: `calc(1em + ${theme.spacing(4)})`,
  transition: theme.transitions.create('width'),
  width: '100%',
  [theme.breakpoints.up('md')]: {
    width: '20ch',
    '&:focus': {
      width: '30ch',
    },
  },
  border: 'none',
  background: 'transparent',
  '&:focus': {
    outline: 'none',
  },
}));

export const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const { user, isAuthenticated, logout } = useAuth();
  const { itemCount } = useCart();
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = () => {
    handleMenuClose();
    logout();
  };

  const menuItems = [
    { text: 'Home', icon: <Home />, path: '/' },
    { text: 'Products', icon: <Category />, path: '/products' },
  ];

  const userMenuItems = [
    { text: 'Profile', icon: <Person />, onClick: () => navigate('/profile') },
    { text: 'Orders', icon: <ShoppingBag />, onClick: () => navigate('/orders') },
  ];

  if (user?.isAdmin) {
    userMenuItems.push({
      text: 'Admin',
      icon: <AdminPanelSettings />,
      onClick: () => navigate('/admin'),
    });
  }

  const drawer = (
    <DrawerContainer>
      <Toolbar />
      <Divider />
      <List>
        {menuItems.map((item) => (
          <ListItem
            button
            key={item.text}
            component={RouterLink}
            to={item.path}
            onClick={handleDrawerToggle}
          >
            <ListItemIcon>{item.icon}</ListItemIcon>
            <ListItemText primary={item.text} />
          </ListItem>
        ))}
      </List>
      {isAuthenticated && (
        <>
          <Divider />
          <List>
            {userMenuItems.map((item) => (
              <ListItem
                button
                key={item.text}
                onClick={() => {
                  item.onClick();
                  handleDrawerToggle();
                }}
              >
                <ListItemIcon>{item.icon}</ListItemIcon>
                <ListItemText primary={item.text} />
              </ListItem>
            ))}
            <ListItem button onClick={handleLogout}>
              <ListItemIcon>
                <ExitToApp />
              </ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItem>
          </List>
        </>
      )}
    </DrawerContainer>
  );

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
      <StyledAppBar position="fixed">
        <Container maxWidth="xl">
          <StyledToolbar disableGutters>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <IconButton
                color="inherit"
                aria-label="open drawer"
                edge="start"
                onClick={handleDrawerToggle}
                sx={{ mr: 2, display: { md: 'none' } }}
              >
                <MenuIcon />
              </IconButton>
              <Typography
                variant="h6"
                noWrap
                component={RouterLink}
                to="/"
                sx={{
                  fontWeight: 700,
                  color: 'inherit',
                  textDecoration: 'none',
                  '&:hover': {
                    color: 'primary.main',
                  },
                }}
              >
                E-Commerce
              </Typography>
              <Box sx={{ display: { xs: 'none', md: 'flex' }, ml: 4 }}>
                {menuItems.map((item) => (
                  <Button
                    key={item.text}
                    component={RouterLink}
                    to={item.path}
                    sx={{ color: 'inherit' }}
                  >
                    {item.text}
                  </Button>
                ))}
              </Box>
            </Box>

            <SearchContainer>
              <SearchIconWrapper>
                <Search />
              </SearchIconWrapper>
              <SearchInput
                placeholder="Search products..."
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    const searchQuery = (e.target as HTMLInputElement).value;
                    navigate(`/search?q=${encodeURIComponent(searchQuery)}`);
                  }
                }}
              />
            </SearchContainer>

            <NavItems>
              <IconButton
                color="inherit"
                component={RouterLink}
                to="/cart"
                aria-label="shopping cart"
              >
                <Badge badgeContent={itemCount} color="secondary">
                  <ShoppingCart />
                </Badge>
              </IconButton>

              {isAuthenticated ? (
                <>
                  <Tooltip title="Account settings">
                    <IconButton
                      onClick={handleProfileMenuOpen}
                      size="small"
                      sx={{ ml: 2 }}
                      aria-controls="account-menu"
                      aria-haspopup="true"
                    >
                      <Avatar
                        alt={user.name || 'User'}
                        src={user.avatar}
                        sx={{ width: 32, height: 32 }}
                      >
                        {user.name ? user.name.charAt(0).toUpperCase() : 'U'}
                      </Avatar>
                    </IconButton>
                  </Tooltip>
                  <Menu
                    id="account-menu"
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={handleMenuClose}
                    onClick={handleMenuClose}
                    PaperProps={{
                      elevation: 0,
                      sx: {
                        overflow: 'visible',
                        filter: 'drop-shadow(0px 2px 8px rgba(0,0,0,0.32))',
                        mt: 1.5,
                        '& .MuiAvatar-root': {
                          width: 32,
                          height: 32,
                          ml: -0.5,
                          mr: 1,
                        },
                      },
                    }}
                    transformOrigin={{ horizontal: 'right', vertical: 'top' }}
                    anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
                  >
                    <MenuItem onClick={() => navigate('/profile')}>
                      <Avatar /> Profile
                    </MenuItem>
                    <MenuItem onClick={() => navigate('/orders')}>
                      <ListItemIcon>
                        <ShoppingBag fontSize="small" />
                      </ListItemIcon>
                      My Orders
                    </MenuItem>
                    {user?.isAdmin && (
                      <MenuItem onClick={() => navigate('/admin')}>
                        <ListItemIcon>
                          <AdminPanelSettings fontSize="small" />
                        </ListItemIcon>
                        Admin Dashboard
                      </MenuItem>
                    )}
                    <Divider />
                    <MenuItem onClick={handleLogout}>
                      <ListItemIcon>
                        <ExitToApp fontSize="small" />
                      </ListItemIcon>
                      Logout
                    </MenuItem>
                  </Menu>
                </>
              ) : (
                <>
                  <Button
                    color="inherit"
                    component={RouterLink}
                    to="/login"
                    sx={{ display: { xs: 'none', sm: 'inline-flex' } }}
                  >
                    Login
                  </Button>
                  <Button
                    variant="contained"
                    color="primary"
                    component={RouterLink}
                    to="/register"
                    sx={{ ml: 1, display: { xs: 'none', sm: 'inline-flex' } }}
                  >
                    Sign Up
                  </Button>
                </>
              )}
            </NavItems>
          </StyledToolbar>
        </Container>
      </StyledAppBar>

      <Box component="nav">
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better open performance on mobile.
          }}
          sx={{
            display: { xs: 'block', md: 'none' },
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: 240,
            },
          }}
        >
          {drawer}
        </Drawer>
      </Box>

      <MainContent>
        <Toolbar /> {/* This is for proper spacing below the app bar */}
        <Container maxWidth="xl" sx={{ height: '100%' }}>
          {children}
        </Container>
      </MainContent>

      <Footer>
        <Container maxWidth="xl">
          <Box
            sx={{
              display: 'flex',
              flexDirection: { xs: 'column', md: 'row' },
              justifyContent: 'space-between',
              alignItems: 'center',
              gap: 2,
            }}
          >
            <Typography variant="body2" color="text.secondary">
               {new Date().getFullYear()} E-Commerce App. All rights reserved.
            </Typography>
            <Box sx={{ display: 'flex', gap: 3 }}>
              <Button
                component="a"
                href="#"
                color="inherit"
                size="small"
              >
                Terms
              </Button>
              <Button
                component="a"
                href="#"
                color="inherit"
                size="small"
              >
                Privacy
              </Button>
              <Button
                component="a"
                href="#"
                color="inherit"
                size="small"
              >
                Contact
              </Button>
            </Box>
          </Box>
        </Container>
      </Footer>
    </Box>
  );
};

export default Layout;

import React, { useState } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Grid,
  Link,
  Paper,
  Divider,
  InputAdornment,
  IconButton,
  Alert,
  CircularProgress,
  Stepper,
  Step,
  StepLabel,
  useTheme,
  useMediaQuery,
  Checkbox,
  FormControlLabel,
} from '@mui/material';
import {
  Email,
  Lock,
  Person,
  Visibility,
  VisibilityOff,
  Google,
  Facebook,
  Apple,
  CheckCircle,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useAuth } from '../contexts/AuthContext';

const StyledPaper = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(4),
  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(6),
  },
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const SocialButton = styled(Button)(({ theme }) => ({
  width: '100%',
  marginBottom: theme.spacing(2),
  padding: theme.spacing(1.5),
  borderRadius: theme.shape.borderRadius,
  textTransform: 'none',
  fontWeight: 500,
}));

const steps = ['Account Details', 'Personal Information', 'Confirmation'];

const RegisterPage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const { register } = useAuth();
  
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: '',
    phone: '',
    address: {
      street: '',
      city: '',
      state: '',
      zipCode: '',
      country: '',
    },
    agreeToTerms: false,
  });
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, checked } = e.target;
    
    if (name === 'agreeToTerms') {
      setFormData({ ...formData, [name]: checked });
    } else if (name.startsWith('address.')) {
      const addressField = name.split('.')[1];
      setFormData({
        ...formData,
        address: {
          ...formData.address,
          [addressField]: value,
        },
      });
    } else {
      setFormData({ ...formData, [name]: value });
    }
  };

  const handleNext = () => {
    // Validate current step
    if (activeStep === 0) {
      // Validate account details
      if (!formData.name || !formData.email || !formData.password || !formData.confirmPassword) {
        setError('Please fill in all required fields');
        return;
      }
      
      if (formData.password !== formData.confirmPassword) {
        setError('Passwords do not match');
        return;
      }
      
      if (formData.password.length < 6) {
        setError('Password must be at least 6 characters long');
        return;
      }
      
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(formData.email)) {
        setError('Please enter a valid email address');
        return;
      }
    } else if (activeStep === 1) {
      // Validate personal information
      if (!formData.phone) {
        setError('Please provide a phone number');
        return;
      }
      
      // Phone validation (simple check)
      const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
      if (!phoneRegex.test(formData.phone)) {
        setError('Please enter a valid phone number');
        return;
      }
    } else if (activeStep === 2) {
      // Validate terms agreement
      if (!formData.agreeToTerms) {
        setError('You must agree to the terms and conditions');
        return;
      }
    }
    
    setError('');
    setActiveStep((prevStep) => prevStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
    setError('');
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.agreeToTerms) {
      setError('You must agree to the terms and conditions');
      return;
    }
    
    try {
      setError('');
      setIsLoading(true);
      await register(formData.name, formData.email, formData.password);
      navigate('/');
    } catch (error: any) {
      setError(error.message || 'Failed to create account. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const renderStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <TextField
              margin="normal"
              required
              fullWidth
              id="name"
              label="Full Name"
              name="name"
              autoComplete="name"
              autoFocus
              value={formData.name}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Person color="action" />
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              value={formData.email}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Email color="action" />
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Lock color="action" />
                  </InputAdornment>
                ),
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowPassword(!showPassword)}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type={showConfirmPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Lock color="action" />
                  </InputAdornment>
                ),
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle confirm password visibility"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      edge="end"
                    >
                      {showConfirmPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
          </>
        );
      case 1:
        return (
          <>
            <TextField
              margin="normal"
              required
              fullWidth
              id="phone"
              label="Phone Number"
              name="phone"
              autoComplete="tel"
              value={formData.phone}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              fullWidth
              id="street"
              label="Street Address"
              name="address.street"
              autoComplete="street-address"
              value={formData.address.street}
              onChange={handleChange}
            />
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="city"
                  label="City"
                  name="address.city"
                  autoComplete="address-level2"
                  value={formData.address.city}
                  onChange={handleChange}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="state"
                  label="State/Province"
                  name="address.state"
                  autoComplete="address-level1"
                  value={formData.address.state}
                  onChange={handleChange}
                />
              </Grid>
            </Grid>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="zipCode"
                  label="Zip/Postal Code"
                  name="address.zipCode"
                  autoComplete="postal-code"
                  value={formData.address.zipCode}
                  onChange={handleChange}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="country"
                  label="Country"
                  name="address.country"
                  autoComplete="country"
                  value={formData.address.country}
                  onChange={handleChange}
                />
              </Grid>
            </Grid>
          </>
        );
      case 2:
        return (
          <>
            <Box sx={{ mb: 3, width: '100%' }}>
              <Typography variant="h6" gutterBottom>
                Account Details
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={4} sm={3}>
                  <Typography variant="body2" color="text.secondary">
                    Name:
                  </Typography>
                </Grid>
                <Grid item xs={8} sm={9}>
                  <Typography variant="body2">{formData.name}</Typography>
                </Grid>
                <Grid item xs={4} sm={3}>
                  <Typography variant="body2" color="text.secondary">
                    Email:
                  </Typography>
                </Grid>
                <Grid item xs={8} sm={9}>
                  <Typography variant="body2">{formData.email}</Typography>
                </Grid>
                <Grid item xs={4} sm={3}>
                  <Typography variant="body2" color="text.secondary">
                    Phone:
                  </Typography>
                </Grid>
                <Grid item xs={8} sm={9}>
                  <Typography variant="body2">{formData.phone}</Typography>
                </Grid>
              </Grid>
            </Box>
            
            {formData.address.street && (
              <Box sx={{ mb: 3, width: '100%' }}>
                <Typography variant="h6" gutterBottom>
                  Address
                </Typography>
                <Typography variant="body2">
                  {formData.address.street}
                  {formData.address.city && `, ${formData.address.city}`}
                  {formData.address.state && `, ${formData.address.state}`}
                  {formData.address.zipCode && ` ${formData.address.zipCode}`}
                  {formData.address.country && `, ${formData.address.country}`}
                </Typography>
              </Box>
            )}
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={formData.agreeToTerms}
                  onChange={handleChange}
                  name="agreeToTerms"
                  color="primary"
                />
              }
              label={
                <Typography variant="body2">
                  I agree to the{' '}
                  <Link component={RouterLink} to="/terms" color="primary">
                    Terms and Conditions
                  </Link>{' '}
                  and{' '}
                  <Link component={RouterLink} to="/privacy" color="primary">
                    Privacy Policy
                  </Link>
                </Typography>
              }
              sx={{ width: '100%', mt: 2 }}
            />
          </>
        );
      default:
        return null;
    }
  };

  return (
    <Container maxWidth="md" sx={{ py: 8 }}>
      <Grid container spacing={4}>
        {/* Left Side - Registration Form */}
        <Grid item xs={12} md={7}>
          <StyledPaper elevation={3}>
            <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
              Create Account
            </Typography>
            <Typography variant="body1" color="text.secondary" gutterBottom align="center">
              Join us to start shopping
            </Typography>

            <Stepper activeStep={activeStep} sx={{ width: '100%', my: 4 }} alternativeLabel>
              {steps.map((label) => (
                <Step key={label}>
                  <StepLabel>{label}</StepLabel>
                </Step>
              ))}
            </Stepper>

            {error && (
              <Alert severity="error" sx={{ width: '100%', mb: 3 }}>
                {error}
              </Alert>
            )}

            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
              {renderStepContent(activeStep)}

              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
                <Button
                  onClick={handleBack}
                  disabled={activeStep === 0}
                  sx={{ visibility: activeStep === 0 ? 'hidden' : 'visible' }}
                >
                  Back
                </Button>
                {activeStep === steps.length - 1 ? (
                  <Button
                    type="submit"
                    variant="contained"
                    color="primary"
                    disabled={isLoading || !formData.agreeToTerms}
                    sx={{ py: 1, px: 4 }}
                  >
                    {isLoading ? <CircularProgress size={24} /> : 'Create Account'}
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={handleNext}
                    sx={{ py: 1, px: 4 }}
                  >
                    Next
                  </Button>
                )}
              </Box>
            </Box>

            {activeStep === 0 && (
              <>
                <Divider sx={{ width: '100%', my: 3 }}>
                  <Typography variant="body2" color="text.secondary">
                    OR
                  </Typography>
                </Divider>

                <Box sx={{ width: '100%' }}>
                  <SocialButton
                    variant="outlined"
                    startIcon={<Google />}
                    onClick={() => {
                      // In a real app, this would integrate with Google OAuth
                      setError('Social login is not implemented in this demo');
                    }}
                  >
                    Continue with Google
                  </SocialButton>
                  <SocialButton
                    variant="outlined"
                    startIcon={<Facebook />}
                    onClick={() => {
                      setError('Social login is not implemented in this demo');
                    }}
                  >
                    Continue with Facebook
                  </SocialButton>
                  <SocialButton
                    variant="outlined"
                    startIcon={<Apple />}
                    onClick={() => {
                      setError('Social login is not implemented in this demo');
                    }}
                  >
                    Continue with Apple
                  </SocialButton>
                </Box>
              </>
            )}

            <Box sx={{ textAlign: 'center', mt: 3 }}>
              <Typography variant="body2">
                Already have an account?{' '}
                <Link
                  component={RouterLink}
                  to="/login"
                  variant="body2"
                  color="primary.main"
                  fontWeight="bold"
                >
                  Sign In
                </Link>
              </Typography>
            </Box>
          </StyledPaper>
        </Grid>

        {/* Right Side - Benefits */}
        <Grid
          item
          xs={12}
          md={5}
          sx={{
            display: { xs: 'none', md: 'flex' },
            position: 'relative',
          }}
        >
          <Paper
            sx={{
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              padding: 4,
              backgroundColor: 'primary.main',
              color: 'primary.contrastText',
              backgroundImage: 'linear-gradient(135deg, #1976d2 0%, #1565c0 100%)',
              borderRadius: 2,
              boxShadow: 4,
            }}
          >
            <Typography variant="h4" gutterBottom fontWeight="bold">
              Join Our Community
            </Typography>
            <Typography variant="body1" paragraph>
              Create an account to enjoy all the benefits of our store.
            </Typography>

            <Box sx={{ mt: 4 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Fast Checkout</Typography>
                  <Typography variant="body2">
                    Save your details for a quick and easy checkout experience.
                  </Typography>
                </Box>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Order Tracking</Typography>
                  <Typography variant="body2">
                    Track your orders and view your order history anytime.
                  </Typography>
                </Box>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Exclusive Offers</Typography>
                  <Typography variant="body2">
                    Receive personalized offers and promotions just for members.
                  </Typography>
                </Box>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Wishlist</Typography>
                  <Typography variant="body2">
                    Save your favorite items to purchase later.
                  </Typography>
                </Box>
              </Box>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
};

export default RegisterPage;

import React, { useState } from 'react';
import { useNavigate, useLocation, Link as RouterLink } from 'react-router-dom';
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Grid,
  Link,
  Paper,
  Divider,
  InputAdornment,
  IconButton,
  Alert,
  CircularProgress,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  Email,
  Lock,
  Visibility,
  VisibilityOff,
  Google,
  Facebook,
  Apple,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useAuth } from '../contexts/AuthContext';

interface LocationState {
  from?: string;
}

const StyledPaper = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(4),
  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(6),
  },
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const SocialButton = styled(Button)(({ theme }) => ({
  width: '100%',
  marginBottom: theme.spacing(2),
  padding: theme.spacing(1.5),
  borderRadius: theme.shape.borderRadius,
  textTransform: 'none',
  fontWeight: 500,
}));

const LoginPage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const location = useLocation();
  const { login } = useAuth();
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const locationState = location.state as LocationState;
  const from = locationState?.from || '/';

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!email || !password) {
      setError('Please enter both email and password');
      return;
    }
    
    try {
      setError('');
      setIsLoading(true);
      await login(email, password);
      navigate(from);
    } catch (error: any) {
      setError(error.message || 'Failed to login. Please check your credentials.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container maxWidth="md" sx={{ py: 8 }}>
      <Grid container spacing={4} alignItems="stretch">
        {/* Left Side - Login Form */}
        <Grid item xs={12} md={6}>
          <StyledPaper elevation={3}>
            <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
              Welcome Back
            </Typography>
            <Typography variant="body1" color="text.secondary" gutterBottom align="center">
              Sign in to your account to continue
            </Typography>

            {error && (
              <Alert severity="error" sx={{ width: '100%', mt: 2, mb: 2 }}>
                {error}
              </Alert>
            )}

            {from !== '/' && (
              <Alert severity="info" sx={{ width: '100%', mt: 2, mb: 2 }}>
                Please login to continue to {from.replace('/', '')}
              </Alert>
            )}

            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3, width: '100%' }}>
              <TextField
                margin="normal"
                required
                fullWidth
                id="email"
                label="Email Address"
                name="email"
                autoComplete="email"
                autoFocus
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Email color="action" />
                    </InputAdornment>
                  ),
                }}
              />
              <TextField
                margin="normal"
                required
                fullWidth
                name="password"
                label="Password"
                type={showPassword ? 'text' : 'password'}
                id="password"
                autoComplete="current-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Lock color="action" />
                    </InputAdornment>
                  ),
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        aria-label="toggle password visibility"
                        onClick={() => setShowPassword(!showPassword)}
                        edge="end"
                      >
                        {showPassword ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
              <Box sx={{ textAlign: 'right', mt: 1 }}>
                <Link
                  component={RouterLink}
                  to="/forgot-password"
                  variant="body2"
                  color="primary.main"
                >
                  Forgot password?
                </Link>
              </Box>
              <Button
                type="submit"
                fullWidth
                variant="contained"
                color="primary"
                size="large"
                sx={{ mt: 3, mb: 2, py: 1.5 }}
                disabled={isLoading}
              >
                {isLoading ? <CircularProgress size={24} /> : 'Sign In'}
              </Button>
              <Box sx={{ textAlign: 'center', mt: 2 }}>
                <Typography variant="body2">
                  Don't have an account?{' '}
                  <Link
                    component={RouterLink}
                    to="/register"
                    variant="body2"
                    color="primary.main"
                    fontWeight="bold"
                  >
                    Sign Up
                  </Link>
                </Typography>
              </Box>
            </Box>

            <Divider sx={{ width: '100%', my: 3 }}>
              <Typography variant="body2" color="text.secondary">
                OR
              </Typography>
            </Divider>

            <Box sx={{ width: '100%' }}>
              <SocialButton
                variant="outlined"
                startIcon={<Google />}
                onClick={() => {
                  // In a real app, this would integrate with Google OAuth
                  setError('Social login is not implemented in this demo');
                }}
              >
                Continue with Google
              </SocialButton>
              <SocialButton
                variant="outlined"
                startIcon={<Facebook />}
                onClick={() => {
                  setError('Social login is not implemented in this demo');
                }}
              >
                Continue with Facebook
              </SocialButton>
              <SocialButton
                variant="outlined"
                startIcon={<Apple />}
                onClick={() => {
                  setError('Social login is not implemented in this demo');
                }}
              >
                Continue with Apple
              </SocialButton>
            </Box>
          </StyledPaper>
        </Grid>

        {/* Right Side - Image and Info */}
        <Grid
          item
          xs={12}
          md={6}
          sx={{
            display: { xs: 'none', md: 'flex' },
            position: 'relative',
          }}
        >
          <Paper
            sx={{
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              padding: 4,
              backgroundColor: 'primary.main',
              color: 'primary.contrastText',
              backgroundImage: 'linear-gradient(135deg, #1976d2 0%, #1565c0 100%)',
              borderRadius: 2,
              boxShadow: 4,
            }}
          >
            <Typography variant="h4" gutterBottom fontWeight="bold">
              Welcome to Our Store
            </Typography>
            <Typography variant="body1" paragraph align="center">
              Sign in to access your account, track orders, and enjoy a personalized shopping experience.
            </Typography>
            <Box
              sx={{
                mt: 4,
                p: 3,
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                borderRadius: 2,
                width: '100%',
              }}
            >
              <Typography variant="h6" gutterBottom>
                Benefits of creating an account:
              </Typography>
              <ul style={{ paddingLeft: '20px' }}>
                <li>
                  <Typography variant="body2" paragraph>
                    Fast checkout process
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2" paragraph>
                    Save multiple shipping addresses
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2" paragraph>
                    Access your order history
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2" paragraph>
                    Track your orders easily
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2">
                    Receive exclusive offers and discounts
                  </Typography>
                </li>
              </ul>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
};

export default LoginPage;

import React from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Grid,
  Button,
  Divider,
  Paper,
  IconButton,
  TextField,
  Card,
  CardMedia,
  CardContent,
  List,
  ListItem,
  ListItemText,
  Chip,
  Alert,
  CircularProgress,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  Add,
  Remove,
  Delete,
  ShoppingCart,
  KeyboardBackspace,
  ShoppingBag,
  LocalShipping,
  Payment,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useCart } from '../contexts/CartContext';
import { useAuth } from '../contexts/AuthContext';

const CartItemCard = styled(Paper)(({ theme }) => ({
  display: 'flex',
  marginBottom: theme.spacing(2),
  padding: theme.spacing(2),
  [theme.breakpoints.down('sm')]: {
    flexDirection: 'column',
  },
}));

const ProductImage = styled(CardMedia)(({ theme }) => ({
  width: 100,
  height: 100,
  objectFit: 'contain',
  marginRight: theme.spacing(2),
  backgroundColor: '#f5f5f5',
  borderRadius: theme.shape.borderRadius,
  [theme.breakpoints.down('sm')]: {
    width: '100%',
    height: 200,
    marginRight: 0,
    marginBottom: theme.spacing(2),
  },
}));

const QuantityControl = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  border: `1px solid ${theme.palette.divider}`,
  borderRadius: theme.shape.borderRadius,
  width: 'fit-content',
}));

const QuantityButton = styled(IconButton)(({ theme }) => ({
  padding: theme.spacing(0.5),
}));

const QuantityInput = styled(TextField)({
  '& .MuiInputBase-input': {
    textAlign: 'center',
    width: '40px',
    padding: '8px 0',
  },
  '& .MuiOutlinedInput-notchedOutline': {
    border: 'none',
  },
});

const OrderSummary = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(3),
  position: 'sticky',
  top: theme.spacing(2),
}));

const CartPage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const { items, itemCount, total, isLoading, updateQuantity, removeFromCart } = useCart();
  const { isAuthenticated } = useAuth();

  const handleQuantityChange = (productId: string, quantity: number) => {
    updateQuantity(productId, quantity);
  };

  const handleRemoveItem = (productId: string) => {
    removeFromCart(productId);
  };

  const handleCheckout = () => {
    if (!isAuthenticated) {
      navigate('/login', { state: { from: '/checkout' } });
    } else {
      navigate('/checkout');
    }
  };

  if (isLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="60vh">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
        Shopping Cart
      </Typography>

      {items.length === 0 ? (
        <Box textAlign="center" py={8}>
          <ShoppingCart sx={{ fontSize: 80, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h5" gutterBottom>
            Your cart is empty
          </Typography>
          <Typography variant="body1" color="text.secondary" paragraph>
            Looks like you haven't added any products to your cart yet.
          </Typography>
          <Button
            variant="contained"
            color="primary"
            size="large"
            startIcon={<KeyboardBackspace />}
            onClick={() => navigate('/products')}
            sx={{ mt: 2 }}
          >
            Continue Shopping
          </Button>
        </Box>
      ) : (
        <Grid container spacing={4}>
          {/* Cart Items */}
          <Grid item xs={12} md={8}>
            {items.map((item) => (
              <CartItemCard key={item.id} elevation={1}>
                <ProductImage
                  component="img"
                  image={item.imageUrl || '/placeholder-product.png'}
                  alt={item.name}
                  onClick={() => navigate(`/products/${item.id}`)}
                  sx={{ cursor: 'pointer' }}
                />
                <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                  <Box
                    sx={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'flex-start',
                      mb: 1,
                    }}
                  >
                    <Box>
                      <Typography
                        variant="h6"
                        component={RouterLink}
                        to={`/products/${item.id}`}
                        sx={{
                          textDecoration: 'none',
                          color: 'text.primary',
                          '&:hover': { color: 'primary.main' },
                        }}
                      >
                        {item.name}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        Category: {item.category}
                      </Typography>
                      {item.stock < 10 && (
                        <Chip
                          label={`Only ${item.stock} left`}
                          size="small"
                          color="warning"
                          sx={{ mt: 1 }}
                        />
                      )}
                    </Box>
                    <Typography variant="h6" color="primary.main" fontWeight="bold">
                      ${item.price.toFixed(2)}
                    </Typography>
                  </Box>

                  <Box
                    sx={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      mt: 'auto',
                      pt: 1,
                    }}
                  >
                    <QuantityControl>
                      <QuantityButton
                        onClick={() => handleQuantityChange(item.id, item.quantity - 1)}
                        disabled={item.quantity <= 1}
                      >
                        <Remove fontSize="small" />
                      </QuantityButton>
                      <QuantityInput
                        value={item.quantity}
                        onChange={(e) => {
                          const value = parseInt(e.target.value);
                          if (!isNaN(value) && value > 0 && value <= item.stock) {
                            handleQuantityChange(item.id, value);
                          }
                        }}
                        inputProps={{
                          min: 1,
                          max: item.stock,
                          type: 'number',
                        }}
                        variant="outlined"
                        size="small"
                      />
                      <QuantityButton
                        onClick={() => handleQuantityChange(item.id, item.quantity + 1)}
                        disabled={item.quantity >= item.stock}
                      >
                        <Add fontSize="small" />
                      </QuantityButton>
                    </QuantityControl>
                    <IconButton
                      color="error"
                      onClick={() => handleRemoveItem(item.id)}
                      aria-label="Remove item"
                    >
                      <Delete />
                    </IconButton>
                  </Box>
                </Box>
              </CartItemCard>
            ))}

            <Box
              sx={{
                display: 'flex',
                justifyContent: 'space-between',
                mt: 2,
                mb: 4,
              }}
            >
              <Button
                startIcon={<KeyboardBackspace />}
                onClick={() => navigate(-1)}
                sx={{ textTransform: 'none' }}
              >
                Continue Shopping
              </Button>
              <Button
                variant="outlined"
                color="error"
                onClick={() => navigate('/cart/clear')}
                sx={{ textTransform: 'none' }}
              >
                Clear Cart
              </Button>
            </Box>
          </Grid>

          {/* Order Summary */}
          <Grid item xs={12} md={4}>
            <OrderSummary elevation={3}>
              <Typography variant="h6" gutterBottom fontWeight="bold">
                Order Summary
              </Typography>
              <Divider sx={{ mb: 2 }} />

              <List disablePadding>
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Subtotal" />
                  <Typography variant="body1">${total.toFixed(2)}</Typography>
                </ListItem>
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Shipping" />
                  <Typography variant="body1">
                    {total > 100 ? 'Free' : '$10.00'}
                  </Typography>
                </ListItem>
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Tax (10%)" />
                  <Typography variant="body1">
                    ${(total * 0.1).toFixed(2)}
                  </Typography>
                </ListItem>
                <Divider sx={{ my: 1 }} />
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Total" />
                  <Typography variant="h6" fontWeight="bold">
                    $
                    {(
                      total +
                      (total > 100 ? 0 : 10) +
                      total * 0.1
                    ).toFixed(2)}
                  </Typography>
                </ListItem>
              </List>

              <Button
                variant="contained"
                color="primary"
                fullWidth
                size="large"
                onClick={handleCheckout}
                sx={{ mt: 3 }}
              >
                Proceed to Checkout
              </Button>

              {!isAuthenticated && (
                <Alert severity="info" sx={{ mt: 2 }}>
                  Please <RouterLink to="/login">login</RouterLink> to complete
                  your purchase
                </Alert>
              )}

              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom>
                  We Accept
                </Typography>
                <Box
                  sx={{
                    display: 'flex',
                    gap: 1,
                    flexWrap: 'wrap',
                  }}
                >
                  {['Visa', 'Mastercard', 'Amex', 'PayPal'].map((method) => (
                    <Chip
                      key={method}
                      label={method}
                      variant="outlined"
                      size="small"
                    />
                  ))}
                </Box>
              </Box>
            </OrderSummary>
          </Grid>
        </Grid>
      )}

      {/* Features */}
      <Grid container spacing={3} sx={{ mt: 6 }}>
        <Grid item xs={12} sm={4}>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexDirection: 'column',
              textAlign: 'center',
              p: 2,
            }}
          >
            <LocalShipping
              color="primary"
              sx={{ fontSize: 40, mb: 1 }}
            />
            <Typography variant="h6" gutterBottom>
              Free Shipping
            </Typography>
            <Typography variant="body2" color="text.secondary">
              On orders over $100
            </Typography>
          </Box>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexDirection: 'column',
              textAlign: 'center',
              p: 2,
            }}
          >
            <ShoppingBag
              color="primary"
              sx={{ fontSize: 40, mb: 1 }}
            />
            <Typography variant="h6" gutterBottom>
              Easy Returns
            </Typography>
            <Typography variant="body2" color="text.secondary">
              30-day return policy
            </Typography>
          </Box>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexDirection: 'column',
              textAlign: 'center',
              p: 2,
            }}
          >
            <Payment
              color="primary"
              sx={{ fontSize: 40, mb: 1 }}
            />
            <Typography variant="h6" gutterBottom>
              Secure Payment
            </Typography>
            <Typography variant="body2" color="text.secondary">
              100% secure checkout
            </Typography>
          </Box>
        </Grid>
      </Grid>
    </Container>
  );
};

export default CartPage;

import React, { useEffect, useState } from 'react';
import { useQuery } from 'react-query';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Button,
  Grid,
  Card,
  CardContent,
  CardMedia,
  CardActions,
  Chip,
  CircularProgress,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  ShoppingCart,
  FavoriteBorder,
  ArrowForward,
  Star,
  FlashOn,
  LocalShipping,
  Security,
  Refresh,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { Swiper, SwiperSlide } from 'swiper/react';
import { Autoplay, Pagination, Navigation } from 'swiper/modules';
import 'swiper/css';
import 'swiper/css/pagination';
import 'swiper/css/navigation';
import { productApi, Product } from '../services/api';
import { useCart } from '../contexts/CartContext';
import { ProductCard } from '../components/ProductCard';

const HeroSection = styled('section')(({ theme }) => ({
  position: 'relative',
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  padding: theme.spacing(8, 0),
  marginBottom: theme.spacing(6),
  overflow: 'hidden',
}));

const HeroContent = styled(Container)({
  position: 'relative',
  zIndex: 1,
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'flex-start',
  justifyContent: 'center',
  height: '100%',
  padding: '4rem 0',
});

const HeroTitle = styled(Typography)(({ theme }) => ({
  fontWeight: 700,
  marginBottom: theme.spacing(2),
  [theme.breakpoints.up('md')]: {
    fontSize: '3.5rem',
    lineHeight: 1.1,
  },
}));

const HeroSubtitle = styled(Typography)(({ theme }) => ({
  marginBottom: theme.spacing(4),
  maxWidth: '600px',
  opacity: 0.9,
  [theme.breakpoints.up('md')]: {
    fontSize: '1.25rem',
  },
}));

const FeatureCard = styled(Card)(({ theme }) => ({
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  textAlign: 'center',
  padding: theme.spacing(4, 2),
  transition: 'transform 0.3s, box-shadow 0.3s',
  '&:hover': {
    transform: 'translateY(-5px)',
    boxShadow: theme.shadows[8],
  },
}));

const FeatureIcon = styled(Box)(({ theme }) => ({
  width: 60,
  height: 60,
  borderRadius: '50%',
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: theme.spacing(2),
  '& svg': {
    fontSize: '2rem',
  },
}));

const SectionTitle = styled(Typography)(({ theme }) => ({
  position: 'relative',
  display: 'inline-block',
  marginBottom: theme.spacing(4),
  fontWeight: 700,
  '&:after': {
    content: '""',
    position: 'absolute',
    bottom: -8,
    left: 0,
    width: '50%',
    height: 4,
    backgroundColor: theme.palette.primary.main,
    borderRadius: 2,
  },
}));

const HomePage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const { addToCart } = useCart();

  // Fetch featured products
  const {
    data: featuredProducts = [],
    isLoading: isLoadingFeatured,
  } = useQuery<Product[]>('featuredProducts', () =>
    productApi.getProducts({ featured: true, limit: 8 })
  );

  // Fetch new arrivals
  const {
    data: newArrivals = [],
    isLoading: isLoadingNewArrivals,
  } = useQuery<Product[]>('newArrivals', () =>
    productApi.getProducts({ sort: 'newest', limit: 8 })
  );

  // Fetch best sellers
  const {
    data: bestSellers = [],
    isLoading: isLoadingBestSellers,
  } = useQuery<Product[]>('bestSellers', () =>
    productApi.getProducts({ sort: 'bestseller', limit: 8 })
  );

  const handleAddToCart = (productId: string) => {
    addToCart(productId);
  };

  const features = [
    {
      icon: <LocalShipping />,
      title: 'Free Shipping',
      description: 'On all orders over $50',
    },
    {
      icon: <Refresh />,
      title: 'Easy Returns',
      description: '30-day return policy',
    },
    {
      icon: <Security />,
      title: 'Secure Payment',
      description: '100% secure payment',
    },
    {
      icon: <FlashOn />,
      title: 'Fast Delivery',
      description: 'Same day shipping',
    },
  ];

  const heroSlides = [
    {
      title: 'Summer Collection 2024',
      subtitle: 'Discover our new arrivals with up to 30% off',
      image: '/images/hero-1.jpg',
      buttonText: 'Shop Now',
      buttonVariant: 'contained' as const,
    },
    {
      title: 'Limited Time Offer',
      subtitle: 'Get 50% off on selected items',
      image: '/images/hero-2.jpg',
      buttonText: 'View Deals',
      buttonVariant: 'outlined' as const,
    },
    {
      title: 'New Tech Gadgets',
      subtitle: 'The latest tech at unbeatable prices',
      image: '/images/hero-3.jpg',
      buttonText: 'Explore',
      buttonVariant: 'contained' as const,
    },
  ];

  return (
    <Box sx={{ pb: 6 }}>
      {/* Hero Slider */}
      <Box sx={{ mb: 8 }}>
        <Swiper
          spaceBetween={0}
          centeredSlides={true}
          autoplay={{
            delay: 5000,
            disableOnInteraction: false,
          }}
          pagination={{
            clickable: true,
          }}
          navigation={!isMobile}
          modules={[Autoplay, Pagination, Navigation]}
          style={{
            '--swiper-pagination-color': theme.palette.primary.main,
            '--swiper-navigation-color': theme.palette.primary.main,
          }}
        >
          {heroSlides.map((slide, index) => (
            <SwiperSlide key={index}>
              <HeroSection>
                <HeroContent>
                  <Box sx={{ maxWidth: '600px' }}>
                    <Chip
                      label="New Arrival"
                      color="secondary"
                      size="small"
                      sx={{ mb: 2, fontWeight: 600 }}
                    />
                    <HeroTitle variant="h2" component="h1">
                      {slide.title}
                    </HeroTitle>
                    <HeroSubtitle variant="h5">
                      {slide.subtitle}
                    </HeroSubtitle>
                    <Button
                      variant={slide.buttonVariant}
                      color={slide.buttonVariant === 'contained' ? 'secondary' : 'primary'}
                      size="large"
                      endIcon={<ArrowForward />}
                      onClick={() => navigate('/products')}
                      sx={{
                        borderRadius: '50px',
                        px: 4,
                        py: 1.5,
                        fontWeight: 600,
                      }}
                    >
                      {slide.buttonText}
                    </Button>
                  </Box>
                </HeroContent>
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: '50%',
                    backgroundImage: `url(${slide.image})`,
                    backgroundSize: 'cover',
                    backgroundPosition: 'center',
                    opacity: 0.1,
                    [theme.breakpoints.up('md')]: {
                      opacity: 1,
                      backgroundPosition: 'right',
                    },
                  }}
                />
              </HeroSection>
            </SwiperSlide>
          ))}
        </Swiper>
      </Box>

      {/* Features */}
      <Container maxWidth="lg" sx={{ mb: 8 }}>
        <Grid container spacing={3}>
          {features.map((feature, index) => (
            <Grid item xs={12} sm={6} md={3} key={index}>
              <FeatureCard elevation={2}>
                <FeatureIcon>{feature.icon}</FeatureIcon>
                <Typography variant="h6" component="h3" gutterBottom>
                  {feature.title}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {feature.description}
                </Typography>
              </FeatureCard>
            </Grid>
          ))}
        </Grid>
      </Container>

      {/* Featured Products */}
      <Container maxWidth="lg" sx={{ mb: 8 }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 4,
          }}
        >
          <SectionTitle variant="h4" component="h2">
            Featured Products
          </SectionTitle>
          <Button
            endIcon={<ArrowForward />}
            onClick={() => navigate('/products?filter=featured')}
          >
            View All
          </Button>
        </Box>

        {isLoadingFeatured ? (
          <Box display="flex" justifyContent="center" my={8}>
            <CircularProgress />
          </Box>
        ) : (
          <Grid container spacing={3}>
            {featuredProducts.map((product) => (
              <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
                <ProductCard
                  product={product}
                  onAddToCart={handleAddToCart}
                />
              </Grid>
            ))}
          </Grid>
        )}
      </Container>

      {/* New Arrivals */}
      <Box bgcolor="background.paper" py={8}>
        <Container maxWidth="lg">
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              mb: 4,
            }}
          >
            <SectionTitle variant="h4" component="h2">
              New Arrivals
            </SectionTitle>
            <Button
              endIcon={<ArrowForward />}
              onClick={() => navigate('/products?sort=newest')}
            >
              View All
            </Button>
          </Box>

          {isLoadingNewArrivals ? (
            <Box display="flex" justifyContent="center" my={8}>
              <CircularProgress />
            </Box>
          ) : (
            <Grid container spacing={3}>
              {newArrivals.map((product) => (
                <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
                  <ProductCard
                    product={product}
                    onAddToCart={handleAddToCart}
                  />
                </Grid>
              ))}
            </Grid>
          )}
        </Container>
      </Box>

      {/* Best Sellers */}
      <Container maxWidth="lg" sx={{ my: 8 }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 4,
          }}
        >
          <SectionTitle variant="h4" component="h2">
            Best Sellers
          </SectionTitle>
          <Button
            endIcon={<ArrowForward />}
            onClick={() => navigate('/products?sort=bestseller')}
          >
            View All
          </Button>
        </Box>

        {isLoadingBestSellers ? (
          <Box display="flex" justifyContent="center" my={8}>
            <CircularProgress />
          </Box>
        ) : (
          <Grid container spacing={3}>
            {bestSellers.map((product) => (
              <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
                <ProductCard
                  product={product}
                  onAddToCart={handleAddToCart}
                />
              </Grid>
            ))}
          </Grid>
        )}
      </Container>

      {/* Newsletter Section */}
      <Box bgcolor="primary.main" color="primary.contrastText" py={8}>
        <Container maxWidth="md">
          <Box textAlign="center">
            <Typography variant="h4" component="h2" gutterBottom fontWeight="bold">
              Subscribe to Our Newsletter
            </Typography>
            <Typography variant="body1" mb={4} maxWidth="600px" mx="auto">
              Stay updated with our latest products, promotions, and news. Subscribe to
              our newsletter today!
            </Typography>
            <Box
              component="form"
              sx={{
                display: 'flex',
                maxWidth: '500px',
                mx: 'auto',
                '& .MuiOutlinedInput-root': {
                  backgroundColor: 'background.paper',
                },
              }}
            >
              <input
                type="email"
                placeholder="Enter your email"
                style={{
                  flex: 1,
                  padding: '12px 16px',
                  border: 'none',
                  borderRadius: '4px 0 0 4px',
                  fontSize: '1rem',
                  outline: 'none',
                }}
                required
              />
              <Button
                type="submit"
                variant="contained"
                color="secondary"
                sx={{
                  borderRadius: '0 4px 4px 0',
                  px: 4,
                  py: '12px',
                  fontWeight: 600,
                }}
              >
                Subscribe
              </Button>
            </Box>
          </Box>
        </Container>
      </Box>
    </Box>
  );
};

export default HomePage;

E-Commerce Application

A full-stack e-commerce application built with React, TypeScript, Node.js, Express, and MongoDB.

Project Structure

ecommerce-app/  frontend/ # React frontend   src/    components/ # Reusable UI components    pages/ # Page components    services/ # API services    contexts/ # React contexts    types/ # TypeScript types    App.tsx # Main App component   package.json   tsconfig.json  backend/ # Node.js backend   src/    controllers/ # Route controllers    models/ # Database models    routes/ # API routes    middleware/ # Express middleware    index.ts # Entry point   package.json   tsconfig.json  README.md

Features

Frontend

Modern React with TypeScript: Type-safe code with React 18 and TypeScript

Component-Based Architecture: Reusable UI components for consistent design

State Management: React Context API for global state management

API Integration: Axios for API requests with React Query for data fetching, caching, and state management

Routing: React Router v6 for navigation

Form Handling: Form validation and submission

Authentication: JWT-based authentication with protected routes

Responsive Design: Mobile-first approach with Material-UI

Backend

Node.js with Express: RESTful API endpoints

TypeScript: Type-safe backend code

MongoDB with Mongoose: Data modeling and database operations

Authentication: JWT-based authentication and authorization

Input Validation: Request validation

Error Handling: Centralized error handling middleware

Security: Implementation of security best practices

Main Features

User authentication (register, login, profile management)

Product browsing and searching

Product categorization

Shopping cart functionality

Order processing

Payment integration (placeholder)

User reviews and ratings

Admin dashboard for product and order management

API Endpoints

Auth

POST /api/auth/register - Register a new user

POST /api/auth/login - Login user

GET /api/auth/me - Get current user

PUT /api/auth/profile - Update user profile

Products

GET /api/products - Get all products

GET /api/products/:id - Get product by ID

POST /api/products - Create a product (admin)

PUT /api/products/:id - Update a product (admin)

DELETE /api/products/:id - Delete a product (admin)

POST /api/products/:id/reviews - Create product review

GET /api/products/top - Get top rated products

Cart

GET /api/cart - Get user cart

POST /api/cart/items - Add item to cart

PUT /api/cart/items/:productId - Update cart item quantity

DELETE /api/cart/items/:productId - Remove item from cart

DELETE /api/cart - Clear cart

Orders

POST /api/orders - Create new order

GET /api/orders/:id - Get order by ID

PUT /api/orders/:id/pay - Update order to paid

PUT /api/orders/:id/deliver - Update order to delivered (admin)

GET /api/orders/myorders - Get logged in user orders

GET /api/orders - Get all orders (admin)

Getting Started

Prerequisites

Node.js (v14 or higher)

MongoDB

Installation

Clone the repository

Install frontend dependencies: cd frontend npm install

Install backend dependencies: cd backend npm install

Environment Variables

Create a .env file in the backend directory with the following variables:

NODE_ENV=development PORT=3001 MONGO_URI=mongodb://localhost:27017/ecommerce JWT_SECRET=your_jwt_secret JWT_EXPIRES_IN=30d

Running the Application

Start the backend server: cd backend npm run dev

Start the frontend development server: cd frontend npm start

License

This project is licensed under the MIT License.
{"compilerOptions": {"target": "es5", "lib": ["dom", "dom.iterable", "esnext"], "allowJs": true, "skipLibCheck": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "strict": true, "forceConsistentCasingInFileNames": true, "noFallthroughCasesInSwitch": true, "module": "esnext", "moduleResolution": "node", "resolveJsonModule": true, "isolatedModules": true, "noEmit": true, "jsx": "react-jsx", "baseUrl": "src"}, "include": ["src"]}
{"name": "ecommerce-backend", "version": "1.0.0", "description": "Node.js backend for e-commerce application", "main": "dist/index.js", "scripts": {"start": "node dist/index.js", "dev": "nodemon src/index.ts", "build": "tsc", "test": "jest", "lint": "eslint src/**/*.ts", "format": "prettier --write \"src/**/*.ts\""}, "dependencies": {"bcryptjs": "^2.4.3", "cors": "^2.8.5", "dotenv": "^16.0.3", "express": "^4.18.2", "express-validator": "^7.0.1", "jsonwebtoken": "^9.0.0", "mongoose": "^7.1.0", "morgan": "^1.10.0", "multer": "^1.4.5-lts.1", "stripe": "^12.3.0", "winston": "^3.8.2"}, "devDependencies": {"@types/bcryptjs": "^2.4.2", "@types/cors": "^2.8.13", "@types/express": "^4.17.17", "@types/jest": "^29.5.1", "@types/jsonwebtoken": "^9.0.2", "@types/morgan": "^1.9.4", "@types/multer": "^1.4.7", "@types/node": "^18.16.3", "@types/supertest": "^2.0.12", "@typescript-eslint/eslint-plugin": "^5.59.2", "@typescript-eslint/parser": "^5.59.2", "eslint": "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", "jest": "^29.5.0", "nodemon": "^2.0.22", "prettier": "^2.8.8", "supertest": "^6.3.3", "ts-jest": "^29.1.0", "ts-node": "^10.9.1", "typescript": "^5.0.4"}, "engines": {"node": ">=14.0.0"}}
{"compilerOptions": {"target": "es2018", "module": "commonjs", "outDir": "./dist", "rootDir": "./src", "strict": true, "esModuleInterop": true, "skipLibCheck": true, "forceConsistentCasingInFileNames": true, "resolveJsonModule": true, "sourceMap": true, "declaration": true, "removeComments": true, "typeRoots": ["./node_modules/@types", "./src/types"], "baseUrl": "./src", "paths": {"@/*": ["*"]}}, "include": ["src/**/*"], "exclude": ["node_modules", "**/*.test.ts", "dist"]}
E-Commerce Application

A full-stack e-commerce application built with React, TypeScript, Node.js, Express, and MongoDB.

Project Structure

ecommerce-app/  frontend/ # React frontend   src/    components/ # Reusable UI components    pages/ # Page components    services/ # API services    contexts/ # React contexts    types/ # TypeScript types    App.tsx # Main App component   package.json   tsconfig.json  backend/ # Node.js backend   src/    controllers/ # Route controllers    models/ # Database models    routes/ # API routes    middleware/ # Express middleware    index.ts # Entry point   package.json   tsconfig.json  README.md

Features

Frontend

Modern React with TypeScript: Type-safe code with React 18 and TypeScript

Component-Based Architecture: Reusable UI components for consistent design

State Management: React Context API for global state management

API Integration: Axios for API requests with React Query for data fetching, caching, and state management

Routing: React Router v6 for navigation

Form Handling: Form validation and submission

Authentication: JWT-based authentication with protected routes

Responsive Design: Mobile-first approach with Material-UI

Backend

Node.js with Express: RESTful API endpoints

TypeScript: Type-safe backend code

MongoDB with Mongoose: Data modeling and database operations

Authentication: JWT-based authentication and authorization

Input Validation: Request validation

Error Handling: Centralized error handling middleware

Security: Implementation of security best practices

Main Features

User authentication (register, login, profile management)

Product browsing and searching

Product categorization

Shopping cart functionality

Order processing

Payment integration (placeholder)

User reviews and ratings

Admin dashboard for product and order management

API Endpoints

Auth

POST /api/auth/register - Register a new user

POST /api/auth/login - Login user

GET /api/auth/me - Get current user

PUT /api/auth/profile - Update user profile

Products

GET /api/products - Get all products

GET /api/products/:id - Get product by ID

POST /api/products - Create a product (admin)

PUT /api/products/:id - Update a product (admin)

DELETE /api/products/:id - Delete a product (admin)

POST /api/products/:id/reviews - Create product review

GET /api/products/top - Get top rated products

Cart

GET /api/cart - Get user cart

POST /api/cart/items - Add item to cart

PUT /api/cart/items/:productId - Update cart item quantity

DELETE /api/cart/items/:productId - Remove item from cart

DELETE /api/cart - Clear cart

Orders

POST /api/orders - Create new order

GET /api/orders/:id - Get order by ID

PUT /api/orders/:id/pay - Update order to paid

PUT /api/orders/:id/deliver - Update order to delivered (admin)

GET /api/orders/myorders - Get logged in user orders

GET /api/orders - Get all orders (admin)

Getting Started

Prerequisites

Node.js (v14 or higher)

MongoDB

Installation

Clone the repository

Install frontend dependencies: cd frontend npm install

Install backend dependencies: cd backend npm install

Environment Variables

Create a .env file in the backend directory with the following variables:

NODE_ENV=development PORT=3001 MONGO_URI=mongodb://localhost:27017/ecommerce JWT_SECRET=your_jwt_secret JWT_EXPIRES_IN=30d

Running the Application

Start the backend server: cd backend npm run dev

Start the frontend development server: cd frontend npm start

License

This project is licensed under the MIT License.
{"compilerOptions": {"target": "es5", "lib": ["dom", "dom.iterable", "esnext"], "allowJs": true, "skipLibCheck": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "strict": true, "forceConsistentCasingInFileNames": true, "noFallthroughCasesInSwitch": true, "module": "esnext", "moduleResolution": "node", "resolveJsonModule": true, "isolatedModules": true, "noEmit": true, "jsx": "react-jsx", "baseUrl": "src"}, "include": ["src"]}
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { theme } from './theme';
import { Layout } from './components/Layout';
import { HomePage } from './pages/HomePage';
import { ProductPage } from './pages/ProductPage';
import { CartPage } from './pages/CartPage';
import { CheckoutPage } from './pages/CheckoutPage';
import { LoginPage } from './pages/LoginPage';
import { RegisterPage } from './pages/RegisterPage';
import { ProfilePage } from './pages/ProfilePage';
import { OrdersPage } from './pages/OrdersPage';
import { AdminPage } from './pages/admin/AdminPage';
import { ProtectedRoute } from './components/ProtectedRoute';
import { AdminRoute } from './components/AdminRoute';
import { AuthProvider } from './contexts/AuthContext';
import { CartProvider } from './contexts/CartContext';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <AuthProvider>
          <CartProvider>
            <Router>
              <Layout>
                <Routes>
                  <Route path="/" element={<HomePage />} />
                  <Route path="/products/:id" element={<ProductPage />} />
                  <Route path="/cart" element={<CartPage />} />
                  <Route
                    path="/checkout"
                    element={
                      <ProtectedRoute>
                        <CheckoutPage />
                      </ProtectedRoute>
                    }
                  />
                  <Route path="/login" element={<LoginPage />} />
                  <Route path="/register" element={<RegisterPage />} />
                  <Route
                    path="/profile"
                    element={
                      <ProtectedRoute>
                        <ProfilePage />
                      </ProtectedRoute>
                    }
                  />
                  <Route
                    path="/orders"
                    element={
                      <ProtectedRoute>
                        <OrdersPage />
                      </ProtectedRoute>
                    }
                  />
                  <Route
                    path="/admin/*"
                    element={
                      <AdminRoute>
                        <AdminPage />
                      </AdminRoute>
                    }
                  />
                  <Route path="*" element={<div>Not Found</div>} />
                </Routes>
              </Layout>
            </Router>
          </CartProvider>
        </AuthProvider>
      </ThemeProvider>
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  );
}

export default App;

import { createTheme } from '@mui/material/styles';

declare module '@mui/material/styles' {
  interface Theme {
    custom: {
      maxContentWidth: number;
      headerHeight: number;
      footerHeight: number;
    };
  }
  // Allow configuration using `createTheme`
  interface ThemeOptions {
    custom?: {
      maxContentWidth?: number;
      headerHeight?: number;
      footerHeight?: number;
    };
  }
}

export const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
      contrastText: '#fff',
    },
    secondary: {
      main: '#9c27b0',
      light: '#ba68c8',
      dark: '#7b1fa2',
      contrastText: '#fff',
    },
    error: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828',
    },
    warning: {
      main: '#ed6c02',
      light: '#ff9800',
      dark: '#e65100',
    },
    info: {
      main: '#0288d1',
      light: '#03a9f4',
      dark: '#01579b',
    },
    success: {
      main: '#2e7d32',
      light: '#4caf50',
      dark: '#1b5e20',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
      disabled: 'rgba(0, 0, 0, 0.38)',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 500,
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 500,
      lineHeight: 1.3,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
      lineHeight: 1.4,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 500,
      lineHeight: 1.5,
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 4,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '8px 16px',
        },
        contained: {
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0px 2px 4px -1px rgba(0,0,0,0.2), 0px 4px 5px 0px rgba(0,0,0,0.14), 0px 1px 10px 0px rgba(0,0,0,0.12)',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
          transition: 'transform 0.2s, box-shadow 0.2s',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
        },
      },
    },
  },
  custom: {
    maxContentWidth: 1440,
    headerHeight: 64,
    footerHeight: 56,
  },
});

export interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  imageUrl: string;
  category: string;
  stock: number;
  rating: number;
  reviews: Review[];
}

export interface Review {
  id: string;
  userId: string;
  userName: string;
  rating: number;
  comment: string;
  date: string;
}

export interface CartItem extends Product {
  quantity: number;
}

export interface User {
  id: string;
  name: string;
  email: string;
  address?: Address;
  orders: Order[];
}

export interface Address {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}

export interface Order {
  id: string;
  date: string;
  items: OrderItem[];
  total: number;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled';
  shippingAddress: Address;
  paymentMethod: string;
}

export interface OrderItem {
  productId: string;
  name: string;
  quantity: number;
  price: number;
  imageUrl: string;
}

import React, { createContext, useContext, useEffect, useState } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { cartApi, CartItem } from '../services/api';
import { useAuth } from './AuthContext';

type CartContextType = {
  items: CartItem[];
  itemCount: number;
  total: number;
  isLoading: boolean;
  addToCart: (productId: string, quantity?: number) => Promise<void>;
  updateQuantity: (productId: string, quantity: number) => Promise<void>;
  removeFromCart: (productId: string) => Promise<void>;
  clearCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export const CartProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const queryClient = useQueryClient();
  const [localCart, setLocalCart] = useState<Record<string, number>>({});

  // Fetch cart from server if authenticated
  const { data: serverCart = [], isLoading } = useQuery<CartItem[]>(
    'cart',
    cartApi.getCart,
    {
      enabled: isAuthenticated,
      staleTime: 1000 * 60 * 5, // 5 minutes
      onError: (error) => {
        console.error('Failed to fetch cart', error);
      },
    }
  );

  // Sync local cart with server on auth state change
  useEffect(() => {
    if (isAuthenticated) {
      // If we have items in local cart and user logs in, sync with server
      if (Object.keys(localCart).length > 0) {
        const syncCart = async () => {
          try {
            await Promise.all(
              Object.entries(localCart).map(([productId, quantity]) =>
                cartApi.addToCart(productId, quantity)
              )
            );
            setLocalCart({});
            queryClient.invalidateQueries('cart');
          } catch (error) {
            console.error('Failed to sync cart', error);
          }
        };
        syncCart();
      } else {
        // Otherwise just refresh the cart
        queryClient.invalidateQueries('cart');
      }
    }
  }, [isAuthenticated]);

  // Add to cart mutation
  const addToCartMutation = useMutation(
    ({ productId, quantity = 1 }: { productId: string; quantity?: number }) =>
      isAuthenticated
        ? cartApi.addToCart(productId, quantity)
        : Promise.resolve(),
    {
      onMutate: async ({ productId, quantity = 1 }) => {
        if (!isAuthenticated) {
          // Update local cart for unauthenticated users
          setLocalCart((prev) => ({
            ...prev,
            [productId]: (prev[productId] || 0) + quantity,
          }));
          return;
        }
        
        // Optimistic update for authenticated users
        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        const existingItem = previousCart.find((item) => item.id === productId);
        
        if (existingItem) {
          const updatedCart = previousCart.map((item) =>
            item.id === productId
              ? { ...item, quantity: item.quantity + quantity }
              : item
          );
          queryClient.setQueryData('cart', updatedCart);
        } else {
          // In a real app, we would fetch the product details here
          const newItem: CartItem = {
            id: productId,
            name: `Product ${productId}`,
            price: 0,
            quantity,
            description: '',
            imageUrl: '',
            category: '',
            stock: 0,
            rating: 0,
            reviews: [],
          };
          queryClient.setQueryData('cart', [...previousCart, newItem]);
        }
        
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to add to cart', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Update quantity mutation
  const updateQuantityMutation = useMutation(
    ({ productId, quantity }: { productId: string; quantity: number }) =>
      isAuthenticated
        ? cartApi.updateCartItem(productId, quantity)
        : Promise.resolve(),
    {
      onMutate: async ({ productId, quantity }) => {
        if (!isAuthenticated) {
          setLocalCart((prev) => ({
            ...prev,
            [productId]: quantity,
          }));
          return;
        }

        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        const updatedCart = previousCart.map((item) =>
          item.id === productId ? { ...item, quantity } : item
        );
        
        queryClient.setQueryData('cart', updatedCart);
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to update quantity', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Remove from cart mutation
  const removeFromCartMutation = useMutation(
    (productId: string) =>
      isAuthenticated
        ? cartApi.removeFromCart(productId)
        : Promise.resolve(),
    {
      onMutate: async (productId) => {
        if (!isAuthenticated) {
          setLocalCart((prev) => {
            const newCart = { ...prev };
            delete newCart[productId];
            return newCart;
          });
          return;
        }

        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        const updatedCart = previousCart.filter((item) => item.id !== productId);
        queryClient.setQueryData('cart', updatedCart);
        
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to remove from cart', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Clear cart mutation
  const clearCartMutation = useMutation(
    () => (isAuthenticated ? cartApi.clearCart() : Promise.resolve()),
    {
      onMutate: async () => {
        if (!isAuthenticated) {
          setLocalCart({});
          return;
        }

        await queryClient.cancelQueries('cart');
        const previousCart = queryClient.getQueryData<CartItem[]>('cart') || [];
        
        queryClient.setQueryData('cart', []);
        return { previousCart };
      },
      onError: (error, variables, context) => {
        console.error('Failed to clear cart', error);
        if (context?.previousCart) {
          queryClient.setQueryData('cart', context.previousCart);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries('cart');
      },
    }
  );

  // Combine server cart with local cart for unauthenticated users
  const items = isAuthenticated
    ? serverCart
    : Object.entries(localCart).map(([id, quantity]) => ({
        id,
        name: `Product ${id}`,
        price: 0,
        quantity,
        description: '',
        imageUrl: '',
        category: '',
        stock: 0,
        rating: 0,
        reviews: [],
      }));

  const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);
  const total = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  const value = {
    items,
    itemCount,
    total,
    isLoading,
    addToCart: (productId: string, quantity = 1) =>
      addToCartMutation.mutateAsync({ productId, quantity }),
    updateQuantity: (productId: string, quantity: number) =>
      updateQuantityMutation.mutateAsync({ productId, quantity }),
    removeFromCart: (productId: string) =>
      removeFromCartMutation.mutateAsync(productId),
    clearCart: () => clearCartMutation.mutateAsync(),
  };

  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

import React, { createContext, useContext, useEffect, useState } from 'react';
import { useQuery, useQueryClient } from 'react-query';
import { authApi, User } from '../services/api';
import { useNavigate } from 'react-router-dom';

type AuthContextType = {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (name: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  updateUser: (updates: Partial<User>) => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isLoading, setIsLoading] = useState(true);
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  const { data: user, isLoading: isUserLoading } = useQuery<User | null>(
    'currentUser',
    async () => {
      try {
        const token = localStorage.getItem('token');
        if (!token) return null;
        return await authApi.getCurrentUser();
      } catch (error) {
        console.error('Failed to fetch current user', error);
        localStorage.removeItem('token');
        return null;
      }
    },
    {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
    }
  );

  useEffect(() => {
    if (localStorage.getItem('token') && !user && !isUserLoading) {
      queryClient.invalidateQueries('currentUser');
    } else {
      setIsLoading(false);
    }
  }, [user, isUserLoading, queryClient]);

  const login = async (email: string, password: string) => {
    try {
      const { token, user } = await authApi.login({ email, password });
      localStorage.setItem('token', token);
      queryClient.setQueryData('currentUser', user);
      navigate('/');
    } catch (error) {
      console.error('Login failed', error);
      throw error;
    }
  };

  const register = async (name: string, email: string, password: string) => {
    try {
      const { token, user } = await authApi.register({ name, email, password });
      localStorage.setItem('token', token);
      queryClient.setQueryData('currentUser', user);
      navigate('/');
    } catch (error) {
      console.error('Registration failed', error);
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    queryClient.setQueryData('currentUser', null);
    queryClient.clear();
    navigate('/login');
  };

  const updateUser = async (updates: Partial<User>) => {
    if (!user) return;
    try {
      const updatedUser = await authApi.updateProfile(updates);
      queryClient.setQueryData('currentUser', updatedUser);
    } catch (error) {
      console.error('Failed to update user', error);
      throw error;
    }
  };

  const value = {
    user: user || null,
    isLoading: isLoading || isUserLoading,
    isAuthenticated: !!user,
    login,
    register,
    logout,
    updateUser,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

/**
 * Validation utility functions for frontend forms
 */

/**
 * Validate email format
 * @param email Email to validate
 * @returns True if valid, false otherwise
 */
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

/**
 * Validate password strength
 * @param password Password to validate
 * @returns Object with validation result and message
 */
export const validatePassword = (password: string): { isValid: boolean; message: string } => {
  if (password.length < 8) {
    return { isValid: false, message: 'Password must be at least 8 characters long' };
  }
  
  if (!/[A-Z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one uppercase letter' };
  }
  
  if (!/[a-z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one lowercase letter' };
  }
  
  if (!/[0-9]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one number' };
  }
  
  return { isValid: true, message: 'Password is strong' };
};

/**
 * Validate that passwords match
 * @param password Password
 * @param confirmPassword Confirmation password
 * @returns True if matching, false otherwise
 */
export const passwordsMatch = (password: string, confirmPassword: string): boolean => {
  return password === confirmPassword;
};

/**
 * Validate phone number format
 * @param phone Phone number to validate
 * @returns True if valid, false otherwise
 */
export const isValidPhone = (phone: string): boolean => {
  const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
  return phoneRegex.test(phone);
};

/**
 * Validate required field
 * @param value Field value
 * @returns True if not empty, false otherwise
 */
export const isNotEmpty = (value: string): boolean => {
  return value.trim().length > 0;
};

/**
 * Validate minimum length
 * @param value Field value
 * @param minLength Minimum length
 * @returns True if valid, false otherwise
 */
export const hasMinLength = (value: string, minLength: number): boolean => {
  return value.length >= minLength;
};

/**
 * Validate maximum length
 * @param value Field value
 * @param maxLength Maximum length
 * @returns True if valid, false otherwise
 */
export const hasMaxLength = (value: string, maxLength: number): boolean => {
  return value.length <= maxLength;
};

/**
 * Validate numeric value
 * @param value Field value
 * @returns True if numeric, false otherwise
 */
export const isNumeric = (value: string): boolean => {
  return /^\d+$/.test(value);
};

/**
 * Validate decimal value
 * @param value Field value
 * @returns True if decimal, false otherwise
 */
export const isDecimal = (value: string): boolean => {
  return /^\d+(\.\d+)?$/.test(value);
};

/**
 * Validate URL format
 * @param url URL to validate
 * @returns True if valid, false otherwise
 */
export const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
};

/**
 * Validate postal/zip code format
 * @param code Postal/zip code to validate
 * @param countryCode Country code (default: 'US')
 * @returns True if valid, false otherwise
 */
export const isValidPostalCode = (code: string, countryCode: string = 'US'): boolean => {
  // Basic validation for common country formats
  const postalRegexes: { [key: string]: RegExp } = {
    US: /^\d{5}(-\d{4})?$/,
    CA: /^[A-Za-z]\d[A-Za-z][ -]?\d[A-Za-z]\d$/,
    UK: /^[A-Za-z]{1,2}\d[A-Za-z\d]? \d[A-Za-z]{2}$/,
    AU: /^\d{4}$/,
    DE: /^\d{5}$/,
    FR: /^\d{5}$/,
    IT: /^\d{5}$/,
    ES: /^\d{5}$/,
    NL: /^\d{4}[ ]?[A-Za-z]{2}$/,
    BE: /^\d{4}$/,
  };
  
  const regex = postalRegexes[countryCode] || postalRegexes.US;
  return regex.test(code);
};

/**
 * Validate credit card number using Luhn algorithm
 * @param cardNumber Credit card number to validate
 * @returns True if valid, false otherwise
 */
export const isValidCreditCard = (cardNumber: string): boolean => {
  // Remove spaces and dashes
  const sanitized = cardNumber.replace(/[\s-]/g, '');
  
  // Check if contains only digits
  if (!/^\d+$/.test(sanitized)) {
    return false;
  }
  
  // Check length (most cards are 13-19 digits)
  if (sanitized.length < 13 || sanitized.length > 19) {
    return false;
  }
  
  // Luhn algorithm
  let sum = 0;
  let double = false;
  
  // Loop from right to left
  for (let i = sanitized.length - 1; i >= 0; i--) {
    let digit = parseInt(sanitized.charAt(i), 10);
    
    if (double) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }
    
    sum += digit;
    double = !double;
  }
  
  return sum % 10 === 0;
};

/**
 * Validate credit card expiration date
 * @param month Expiration month (1-12)
 * @param year Expiration year (4 digits)
 * @returns True if valid and not expired, false otherwise
 */
export const isValidExpirationDate = (month: number, year: number): boolean => {
  const now = new Date();
  const currentMonth = now.getMonth() + 1; // getMonth() returns 0-11
  const currentYear = now.getFullYear();
  
  // Check if month is valid
  if (month < 1 || month > 12) {
    return false;
  }
  
  // Check if expired
  if (year < currentYear || (year === currentYear && month < currentMonth)) {
    return false;
  }
  
  return true;
};

/**
 * Validate CVV code
 * @param cvv CVV code
 * @param cardType Card type (default: 'visa')
 * @returns True if valid, false otherwise
 */
export const isValidCVV = (cvv: string, cardType: string = 'visa'): boolean => {
  // Remove spaces
  const sanitized = cvv.replace(/\s/g, '');
  
  // Check if contains only digits
  if (!/^\d+$/.test(sanitized)) {
    return false;
  }
  
  // American Express uses 4-digit CVV, others use 3-digit
  const expectedLength = cardType.toLowerCase() === 'amex' ? 4 : 3;
  
  return sanitized.length === expectedLength;
};

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';

// API base URL from environment variables
const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

// Default request timeout in milliseconds
const REQUEST_TIMEOUT = 30000;

// Create axios instance with default config
const axiosInstance: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: REQUEST_TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add auth token
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle common errors
axiosInstance.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    // Handle token expiration
    if (error.response?.status === 401) {
      // Clear token and redirect to login
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    
    // Handle server errors
    if (error.response?.status === 500) {
      console.error('Server error:', error);
    }
    
    return Promise.reject(error);
  }
);

/**
 * Generic API request function
 * @param method HTTP method
 * @param url API endpoint
 * @param data Request data
 * @param config Additional axios config
 * @returns Promise with response data
 */
const apiRequest = async <T = any>(
  method: string,
  url: string,
  data?: any,
  config?: AxiosRequestConfig
): Promise<T> => {
  try {
    const response: AxiosResponse<T> = await axiosInstance({
      method,
      url,
      data,
      ...config,
    });
    
    return response.data;
  } catch (error: any) {
    // Format error message
    let errorMessage = 'An unexpected error occurred';
    
    if (error.response) {
      // Server responded with an error status
      errorMessage = error.response.data?.message || `Error: ${error.response.status}`;
    } else if (error.request) {
      // Request was made but no response received
      errorMessage = 'No response from server. Please check your internet connection.';
    } else {
      // Error in setting up the request
      errorMessage = error.message;
    }
    
    // Create a custom error object
    const customError = new Error(errorMessage);
    (customError as any).originalError = error;
    (customError as any).status = error.response?.status;
    
    throw customError;
  }
};

// API methods
export const api = {
  /**
   * GET request
   * @param url API endpoint
   * @param config Additional axios config
   * @returns Promise with response data
   */
  get: <T = any>(url: string, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('get', url, undefined, config);
  },
  
  /**
   * POST request
   * @param url API endpoint
   * @param data Request data
   * @param config Additional axios config
   * @returns Promise with response data
   */
  post: <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('post', url, data, config);
  },
  
  /**
   * PUT request
   * @param url API endpoint
   * @param data Request data
   * @param config Additional axios config
   * @returns Promise with response data
   */
  put: <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('put', url, data, config);
  },
  
  /**
   * PATCH request
   * @param url API endpoint
   * @param data Request data
   * @param config Additional axios config
   * @returns Promise with response data
   */
  patch: <T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('patch', url, data, config);
  },
  
  /**
   * DELETE request
   * @param url API endpoint
   * @param config Additional axios config
   * @returns Promise with response data
   */
  delete: <T = any>(url: string, config?: AxiosRequestConfig): Promise<T> => {
    return apiRequest<T>('delete', url, undefined, config);
  },
  
  /**
   * Upload file(s)
   * @param url API endpoint
   * @param formData FormData with files
   * @param onProgress Progress callback
   * @returns Promise with response data
   */
  upload: <T = any>(
    url: string,
    formData: FormData,
    onProgress?: (progressEvent: any) => void
  ): Promise<T> => {
    const config: AxiosRequestConfig = {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    };
    
    if (onProgress) {
      config.onUploadProgress = onProgress;
    }
    
    return apiRequest<T>('post', url, formData, config);
  },
};

export default api;

/**
 * Format a price with currency symbol
 * @param price Price to format
 * @param currency Currency code (default: USD)
 * @returns Formatted price string
 */
export const formatPrice = (price: number, currency: string = 'USD'): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(price);
};

/**
 * Format a date to a readable string
 * @param date Date to format
 * @param options Intl.DateTimeFormatOptions
 * @returns Formatted date string
 */
export const formatDate = (
  date: Date | string,
  options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }
): string => {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return new Intl.DateTimeFormat('en-US', options).format(dateObj);
};

/**
 * Format a date to a relative time string (e.g., "2 days ago")
 * @param date Date to format
 * @returns Relative time string
 */
export const formatRelativeTime = (date: Date | string): string => {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - dateObj.getTime()) / 1000);
  
  // Less than a minute
  if (diffInSeconds < 60) {
    return 'just now';
  }
  
  // Less than an hour
  if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  }
  
  // Less than a day
  if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  }
  
  // Less than a week
  if (diffInSeconds < 604800) {
    const days = Math.floor(diffInSeconds / 86400);
    return `${days} day${days > 1 ? 's' : ''} ago`;
  }
  
  // Less than a month
  if (diffInSeconds < 2592000) {
    const weeks = Math.floor(diffInSeconds / 604800);
    return `${weeks} week${weeks > 1 ? 's' : ''} ago`;
  }
  
  // Less than a year
  if (diffInSeconds < 31536000) {
    const months = Math.floor(diffInSeconds / 2592000);
    return `${months} month${months > 1 ? 's' : ''} ago`;
  }
  
  // More than a year
  const years = Math.floor(diffInSeconds / 31536000);
  return `${years} year${years > 1 ? 's' : ''} ago`;
};

/**
 * Truncate a string to a specified length
 * @param str String to truncate
 * @param maxLength Maximum length
 * @param suffix Suffix to add if truncated (default: "...")
 * @returns Truncated string
 */
export const truncateString = (
  str: string,
  maxLength: number,
  suffix: string = '...'
): string => {
  if (str.length <= maxLength) {
    return str;
  }
  
  return str.substring(0, maxLength - suffix.length) + suffix;
};

/**
 * Format a phone number to a readable format
 * @param phone Phone number to format
 * @returns Formatted phone number
 */
export const formatPhoneNumber = (phone: string): string => {
  // Remove all non-numeric characters
  const cleaned = phone.replace(/\D/g, '');
  
  // Check if the input is valid
  if (cleaned.length < 10) {
    return phone;
  }
  
  // Format the phone number
  if (cleaned.length === 10) {
    return `(${cleaned.substring(0, 3)}) ${cleaned.substring(3, 6)}-${cleaned.substring(6, 10)}`;
  }
  
  // Handle international numbers
  return `+${cleaned.substring(0, cleaned.length - 10)} (${cleaned.substring(cleaned.length - 10, cleaned.length - 7)}) ${cleaned.substring(cleaned.length - 7, cleaned.length - 4)}-${cleaned.substring(cleaned.length - 4)}`;
};

/**
 * Format a file size to a readable string
 * @param bytes Size in bytes
 * @param decimals Number of decimal places (default: 2)
 * @returns Formatted size string
 */
export const formatFileSize = (bytes: number, decimals: number = 2): string => {
  if (bytes === 0) {
    return '0 Bytes';
  }
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
};

/**
 * Format a number with commas
 * @param num Number to format
 * @returns Formatted number string
 */
export const formatNumber = (num: number): string => {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};

import api from './api';

export interface User {
  _id: string;
  name: string;
  email: string;
  role: 'user' | 'admin';
  avatar?: string;
  createdAt: string;
  updatedAt: string;
}

export interface AuthResponse {
  success: boolean;
  message: string;
  data: {
    token: string;
    user: User;
  };
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterData {
  name: string;
  email: string;
  password: string;
}

/**
 * Login user with email and password
 * @param credentials Login credentials
 * @returns Authentication response
 */
export const login = async (credentials: LoginCredentials): Promise<AuthResponse> => {
  const response = await api.post<AuthResponse>('/auth/login', credentials);
  
  if (response.success && response.data.token) {
    // Store token in localStorage
    localStorage.setItem('token', response.data.token);
    // Store user data in localStorage
    localStorage.setItem('user', JSON.stringify(response.data.user));
  }
  
  return response;
};

/**
 * Register a new user
 * @param userData User registration data
 * @returns Authentication response
 */
export const register = async (userData: RegisterData): Promise<AuthResponse> => {
  const response = await api.post<AuthResponse>('/auth/register', userData);
  
  if (response.success && response.data.token) {
    // Store token in localStorage
    localStorage.setItem('token', response.data.token);
    // Store user data in localStorage
    localStorage.setItem('user', JSON.stringify(response.data.user));
  }
  
  return response;
};

/**
 * Logout user
 */
export const logout = (): void => {
  // Remove token from localStorage
  localStorage.removeItem('token');
  // Remove user data from localStorage
  localStorage.removeItem('user');
  // Redirect to login page
  window.location.href = '/login';
};

/**
 * Get current authenticated user
 * @returns User object or null
 */
export const getCurrentUser = (): User | null => {
  const userString = localStorage.getItem('user');
  if (!userString) {
    return null;
  }
  
  try {
    return JSON.parse(userString) as User;
  } catch (error) {
    console.error('Error parsing user data:', error);
    return null;
  }
};

/**
 * Check if user is authenticated
 * @returns Boolean indicating if user is authenticated
 */
export const isAuthenticated = (): boolean => {
  return !!localStorage.getItem('token');
};

/**
 * Check if user is an admin
 * @returns Boolean indicating if user is an admin
 */
export const isAdmin = (): boolean => {
  const user = getCurrentUser();
  return user?.role === 'admin';
};

/**
 * Update user profile
 * @param userData User data to update
 * @returns Updated user data
 */
export const updateProfile = async (userData: Partial<User>): Promise<User> => {
  const response = await api.put<{ success: boolean; data: User }>('/auth/profile', userData);
  
  if (response.success) {
    // Update user data in localStorage
    const currentUser = getCurrentUser();
    const updatedUser = { ...currentUser, ...response.data };
    localStorage.setItem('user', JSON.stringify(updatedUser));
    
    return updatedUser;
  }
  
  throw new Error('Failed to update profile');
};

/**
 * Change user password
 * @param currentPassword Current password
 * @param newPassword New password
 * @returns Success message
 */
export const changePassword = async (
  currentPassword: string,
  newPassword: string
): Promise<string> => {
  const response = await api.put<{ success: boolean; message: string }>(
    '/auth/change-password',
    { currentPassword, newPassword }
  );
  
  if (response.success) {
    return response.message;
  }
  
  throw new Error('Failed to change password');
};

/**
 * Request password reset
 * @param email User email
 * @returns Success message
 */
export const requestPasswordReset = async (email: string): Promise<string> => {
  const response = await api.post<{ success: boolean; message: string }>(
    '/auth/forgot-password',
    { email }
  );
  
  if (response.success) {
    return response.message;
  }
  
  throw new Error('Failed to request password reset');
};

/**
 * Reset password with token
 * @param token Reset token
 * @param newPassword New password
 * @returns Success message
 */
export const resetPassword = async (
  token: string,
  newPassword: string
): Promise<string> => {
  const response = await api.post<{ success: boolean; message: string }>(
    '/auth/reset-password',
    { token, newPassword }
  );
  
  if (response.success) {
    return response.message;
  }
  
  throw new Error('Failed to reset password');
};

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { CircularProgress, Box } from '@mui/material';

type ProtectedRouteProps = {
  children: React.ReactNode;
  adminOnly?: boolean;
};

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  adminOnly = false 
}) => {
  const { user, isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="60vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to when they were redirected. This allows us to send them
    // along to that page after they log in, which is a nicer user experience
    // than dropping them off on the home page.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (adminOnly && !user?.isAdmin) {
    // User is not an admin but trying to access an admin route
    return <Navigate to="/unauthorized" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export const AdminRoute: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  return <ProtectedRoute adminOnly>{children}</ProtectedRoute>;
};

import React, { useState } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Badge,
  Box,
  Container,
  useMediaQuery,
  useTheme,
  Avatar,
  Menu,
  MenuItem,
  Tooltip,
} from '@mui/material';
import {
  Menu as MenuIcon,
  ShoppingCart,
  Home,
  Category,
  Person,
  ExitToApp,
  ShoppingBag,
  AdminPanelSettings,
  Search,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useAuth } from '../contexts/AuthContext';
import { useCart } from '../contexts/CartContext';

const StyledAppBar = styled(AppBar)(({ theme }) => ({
  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
  backgroundColor: theme.palette.background.paper,
  color: theme.palette.text.primary,
}));

const StyledToolbar = styled(Toolbar)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  padding: theme.spacing(0, 2),
  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(0, 4),
  },
}));

const NavItems = styled('div')(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  gap: theme.spacing(2),
}));

const DrawerContainer = styled('div')(({ theme }) => ({
  width: 250,
  padding: theme.spacing(2, 0),
}));

const MainContent = styled('main')(({ theme }) => ({
  flexGrow: 1,
  padding: theme.spacing(3, 0),
  minHeight: `calc(100vh - ${theme.mixins.toolbar.minHeight}px - 64px)`,
  [theme.breakpoints.up('sm')]: {
    padding: theme.spacing(4, 0),
  },
}));

const Footer = styled('footer')(({ theme }) => ({
  backgroundColor: theme.palette.background.paper,
  padding: theme.spacing(3, 0),
  marginTop: 'auto',
  borderTop: `1px solid ${theme.palette.divider}`,
}));

const SearchContainer = styled('div')(({ theme }) => ({
  position: 'relative',
  borderRadius: theme.shape.borderRadius,
  backgroundColor: theme.palette.action.hover,
  marginRight: theme.spacing(2),
  marginLeft: 0,
  width: '100%',
  [theme.breakpoints.up('sm')]: {
    marginLeft: theme.spacing(3),
    width: 'auto',
  },
}));

const SearchIconWrapper = styled('div')(({ theme }) => ({
  padding: theme.spacing(0, 2),
  height: '100%',
  position: 'absolute',
  pointerEvents: 'none',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
}));

const SearchInput = styled('input')(({ theme }) => ({
  color: 'inherit',
  padding: theme.spacing(1, 1, 1, 0),
  paddingLeft: `calc(1em + ${theme.spacing(4)})`,
  transition: theme.transitions.create('width'),
  width: '100%',
  [theme.breakpoints.up('md')]: {
    width: '20ch',
    '&:focus': {
      width: '30ch',
    },
  },
  border: 'none',
  background: 'transparent',
  '&:focus': {
    outline: 'none',
  },
}));

export const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const { user, isAuthenticated, logout } = useAuth();
  const { itemCount } = useCart();
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = () => {
    handleMenuClose();
    logout();
  };

  const menuItems = [
    { text: 'Home', icon: <Home />, path: '/' },
    { text: 'Products', icon: <Category />, path: '/products' },
  ];

  const userMenuItems = [
    { text: 'Profile', icon: <Person />, onClick: () => navigate('/profile') },
    { text: 'Orders', icon: <ShoppingBag />, onClick: () => navigate('/orders') },
  ];

  if (user?.isAdmin) {
    userMenuItems.push({
      text: 'Admin',
      icon: <AdminPanelSettings />,
      onClick: () => navigate('/admin'),
    });
  }

  const drawer = (
    <DrawerContainer>
      <Toolbar />
      <Divider />
      <List>
        {menuItems.map((item) => (
          <ListItem
            button
            key={item.text}
            component={RouterLink}
            to={item.path}
            onClick={handleDrawerToggle}
          >
            <ListItemIcon>{item.icon}</ListItemIcon>
            <ListItemText primary={item.text} />
          </ListItem>
        ))}
      </List>
      {isAuthenticated && (
        <>
          <Divider />
          <List>
            {userMenuItems.map((item) => (
              <ListItem
                button
                key={item.text}
                onClick={() => {
                  item.onClick();
                  handleDrawerToggle();
                }}
              >
                <ListItemIcon>{item.icon}</ListItemIcon>
                <ListItemText primary={item.text} />
              </ListItem>
            ))}
            <ListItem button onClick={handleLogout}>
              <ListItemIcon>
                <ExitToApp />
              </ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItem>
          </List>
        </>
      )}
    </DrawerContainer>
  );

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
      <StyledAppBar position="fixed">
        <Container maxWidth="xl">
          <StyledToolbar disableGutters>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <IconButton
                color="inherit"
                aria-label="open drawer"
                edge="start"
                onClick={handleDrawerToggle}
                sx={{ mr: 2, display: { md: 'none' } }}
              >
                <MenuIcon />
              </IconButton>
              <Typography
                variant="h6"
                noWrap
                component={RouterLink}
                to="/"
                sx={{
                  fontWeight: 700,
                  color: 'inherit',
                  textDecoration: 'none',
                  '&:hover': {
                    color: 'primary.main',
                  },
                }}
              >
                E-Commerce
              </Typography>
              <Box sx={{ display: { xs: 'none', md: 'flex' }, ml: 4 }}>
                {menuItems.map((item) => (
                  <Button
                    key={item.text}
                    component={RouterLink}
                    to={item.path}
                    sx={{ color: 'inherit' }}
                  >
                    {item.text}
                  </Button>
                ))}
              </Box>
            </Box>

            <SearchContainer>
              <SearchIconWrapper>
                <Search />
              </SearchIconWrapper>
              <SearchInput
                placeholder="Search products..."
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    const searchQuery = (e.target as HTMLInputElement).value;
                    navigate(`/search?q=${encodeURIComponent(searchQuery)}`);
                  }
                }}
              />
            </SearchContainer>

            <NavItems>
              <IconButton
                color="inherit"
                component={RouterLink}
                to="/cart"
                aria-label="shopping cart"
              >
                <Badge badgeContent={itemCount} color="secondary">
                  <ShoppingCart />
                </Badge>
              </IconButton>

              {isAuthenticated ? (
                <>
                  <Tooltip title="Account settings">
                    <IconButton
                      onClick={handleProfileMenuOpen}
                      size="small"
                      sx={{ ml: 2 }}
                      aria-controls="account-menu"
                      aria-haspopup="true"
                    >
                      <Avatar
                        alt={user.name || 'User'}
                        src={user.avatar}
                        sx={{ width: 32, height: 32 }}
                      >
                        {user.name ? user.name.charAt(0).toUpperCase() : 'U'}
                      </Avatar>
                    </IconButton>
                  </Tooltip>
                  <Menu
                    id="account-menu"
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={handleMenuClose}
                    onClick={handleMenuClose}
                    PaperProps={{
                      elevation: 0,
                      sx: {
                        overflow: 'visible',
                        filter: 'drop-shadow(0px 2px 8px rgba(0,0,0,0.32))',
                        mt: 1.5,
                        '& .MuiAvatar-root': {
                          width: 32,
                          height: 32,
                          ml: -0.5,
                          mr: 1,
                        },
                      },
                    }}
                    transformOrigin={{ horizontal: 'right', vertical: 'top' }}
                    anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
                  >
                    <MenuItem onClick={() => navigate('/profile')}>
                      <Avatar /> Profile
                    </MenuItem>
                    <MenuItem onClick={() => navigate('/orders')}>
                      <ListItemIcon>
                        <ShoppingBag fontSize="small" />
                      </ListItemIcon>
                      My Orders
                    </MenuItem>
                    {user?.isAdmin && (
                      <MenuItem onClick={() => navigate('/admin')}>
                        <ListItemIcon>
                          <AdminPanelSettings fontSize="small" />
                        </ListItemIcon>
                        Admin Dashboard
                      </MenuItem>
                    )}
                    <Divider />
                    <MenuItem onClick={handleLogout}>
                      <ListItemIcon>
                        <ExitToApp fontSize="small" />
                      </ListItemIcon>
                      Logout
                    </MenuItem>
                  </Menu>
                </>
              ) : (
                <>
                  <Button
                    color="inherit"
                    component={RouterLink}
                    to="/login"
                    sx={{ display: { xs: 'none', sm: 'inline-flex' } }}
                  >
                    Login
                  </Button>
                  <Button
                    variant="contained"
                    color="primary"
                    component={RouterLink}
                    to="/register"
                    sx={{ ml: 1, display: { xs: 'none', sm: 'inline-flex' } }}
                  >
                    Sign Up
                  </Button>
                </>
              )}
            </NavItems>
          </StyledToolbar>
        </Container>
      </StyledAppBar>

      <Box component="nav">
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better open performance on mobile.
          }}
          sx={{
            display: { xs: 'block', md: 'none' },
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: 240,
            },
          }}
        >
          {drawer}
        </Drawer>
      </Box>

      <MainContent>
        <Toolbar /> {/* This is for proper spacing below the app bar */}
        <Container maxWidth="xl" sx={{ height: '100%' }}>
          {children}
        </Container>
      </MainContent>

      <Footer>
        <Container maxWidth="xl">
          <Box
            sx={{
              display: 'flex',
              flexDirection: { xs: 'column', md: 'row' },
              justifyContent: 'space-between',
              alignItems: 'center',
              gap: 2,
            }}
          >
            <Typography variant="body2" color="text.secondary">
               {new Date().getFullYear()} E-Commerce App. All rights reserved.
            </Typography>
            <Box sx={{ display: 'flex', gap: 3 }}>
              <Button
                component="a"
                href="#"
                color="inherit"
                size="small"
              >
                Terms
              </Button>
              <Button
                component="a"
                href="#"
                color="inherit"
                size="small"
              >
                Privacy
              </Button>
              <Button
                component="a"
                href="#"
                color="inherit"
                size="small"
              >
                Contact
              </Button>
            </Box>
          </Box>
        </Container>
      </Footer>
    </Box>
  );
};

export default Layout;

import React, { useState } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Grid,
  Link,
  Paper,
  Divider,
  InputAdornment,
  IconButton,
  Alert,
  CircularProgress,
  Stepper,
  Step,
  StepLabel,
  useTheme,
  useMediaQuery,
  Checkbox,
  FormControlLabel,
} from '@mui/material';
import {
  Email,
  Lock,
  Person,
  Visibility,
  VisibilityOff,
  Google,
  Facebook,
  Apple,
  CheckCircle,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useAuth } from '../contexts/AuthContext';

const StyledPaper = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(4),
  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(6),
  },
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const SocialButton = styled(Button)(({ theme }) => ({
  width: '100%',
  marginBottom: theme.spacing(2),
  padding: theme.spacing(1.5),
  borderRadius: theme.shape.borderRadius,
  textTransform: 'none',
  fontWeight: 500,
}));

const steps = ['Account Details', 'Personal Information', 'Confirmation'];

const RegisterPage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const { register } = useAuth();
  
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: '',
    phone: '',
    address: {
      street: '',
      city: '',
      state: '',
      zipCode: '',
      country: '',
    },
    agreeToTerms: false,
  });
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, checked } = e.target;
    
    if (name === 'agreeToTerms') {
      setFormData({ ...formData, [name]: checked });
    } else if (name.startsWith('address.')) {
      const addressField = name.split('.')[1];
      setFormData({
        ...formData,
        address: {
          ...formData.address,
          [addressField]: value,
        },
      });
    } else {
      setFormData({ ...formData, [name]: value });
    }
  };

  const handleNext = () => {
    // Validate current step
    if (activeStep === 0) {
      // Validate account details
      if (!formData.name || !formData.email || !formData.password || !formData.confirmPassword) {
        setError('Please fill in all required fields');
        return;
      }
      
      if (formData.password !== formData.confirmPassword) {
        setError('Passwords do not match');
        return;
      }
      
      if (formData.password.length < 6) {
        setError('Password must be at least 6 characters long');
        return;
      }
      
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(formData.email)) {
        setError('Please enter a valid email address');
        return;
      }
    } else if (activeStep === 1) {
      // Validate personal information
      if (!formData.phone) {
        setError('Please provide a phone number');
        return;
      }
      
      // Phone validation (simple check)
      const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
      if (!phoneRegex.test(formData.phone)) {
        setError('Please enter a valid phone number');
        return;
      }
    } else if (activeStep === 2) {
      // Validate terms agreement
      if (!formData.agreeToTerms) {
        setError('You must agree to the terms and conditions');
        return;
      }
    }
    
    setError('');
    setActiveStep((prevStep) => prevStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
    setError('');
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.agreeToTerms) {
      setError('You must agree to the terms and conditions');
      return;
    }
    
    try {
      setError('');
      setIsLoading(true);
      await register(formData.name, formData.email, formData.password);
      navigate('/');
    } catch (error: any) {
      setError(error.message || 'Failed to create account. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const renderStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <TextField
              margin="normal"
              required
              fullWidth
              id="name"
              label="Full Name"
              name="name"
              autoComplete="name"
              autoFocus
              value={formData.name}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Person color="action" />
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              value={formData.email}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Email color="action" />
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Lock color="action" />
                  </InputAdornment>
                ),
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowPassword(!showPassword)}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type={showConfirmPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleChange}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <Lock color="action" />
                  </InputAdornment>
                ),
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle confirm password visibility"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      edge="end"
                    >
                      {showConfirmPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
          </>
        );
      case 1:
        return (
          <>
            <TextField
              margin="normal"
              required
              fullWidth
              id="phone"
              label="Phone Number"
              name="phone"
              autoComplete="tel"
              value={formData.phone}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              fullWidth
              id="street"
              label="Street Address"
              name="address.street"
              autoComplete="street-address"
              value={formData.address.street}
              onChange={handleChange}
            />
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="city"
                  label="City"
                  name="address.city"
                  autoComplete="address-level2"
                  value={formData.address.city}
                  onChange={handleChange}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="state"
                  label="State/Province"
                  name="address.state"
                  autoComplete="address-level1"
                  value={formData.address.state}
                  onChange={handleChange}
                />
              </Grid>
            </Grid>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="zipCode"
                  label="Zip/Postal Code"
                  name="address.zipCode"
                  autoComplete="postal-code"
                  value={formData.address.zipCode}
                  onChange={handleChange}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="country"
                  label="Country"
                  name="address.country"
                  autoComplete="country"
                  value={formData.address.country}
                  onChange={handleChange}
                />
              </Grid>
            </Grid>
          </>
        );
      case 2:
        return (
          <>
            <Box sx={{ mb: 3, width: '100%' }}>
              <Typography variant="h6" gutterBottom>
                Account Details
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={4} sm={3}>
                  <Typography variant="body2" color="text.secondary">
                    Name:
                  </Typography>
                </Grid>
                <Grid item xs={8} sm={9}>
                  <Typography variant="body2">{formData.name}</Typography>
                </Grid>
                <Grid item xs={4} sm={3}>
                  <Typography variant="body2" color="text.secondary">
                    Email:
                  </Typography>
                </Grid>
                <Grid item xs={8} sm={9}>
                  <Typography variant="body2">{formData.email}</Typography>
                </Grid>
                <Grid item xs={4} sm={3}>
                  <Typography variant="body2" color="text.secondary">
                    Phone:
                  </Typography>
                </Grid>
                <Grid item xs={8} sm={9}>
                  <Typography variant="body2">{formData.phone}</Typography>
                </Grid>
              </Grid>
            </Box>
            
            {formData.address.street && (
              <Box sx={{ mb: 3, width: '100%' }}>
                <Typography variant="h6" gutterBottom>
                  Address
                </Typography>
                <Typography variant="body2">
                  {formData.address.street}
                  {formData.address.city && `, ${formData.address.city}`}
                  {formData.address.state && `, ${formData.address.state}`}
                  {formData.address.zipCode && ` ${formData.address.zipCode}`}
                  {formData.address.country && `, ${formData.address.country}`}
                </Typography>
              </Box>
            )}
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={formData.agreeToTerms}
                  onChange={handleChange}
                  name="agreeToTerms"
                  color="primary"
                />
              }
              label={
                <Typography variant="body2">
                  I agree to the{' '}
                  <Link component={RouterLink} to="/terms" color="primary">
                    Terms and Conditions
                  </Link>{' '}
                  and{' '}
                  <Link component={RouterLink} to="/privacy" color="primary">
                    Privacy Policy
                  </Link>
                </Typography>
              }
              sx={{ width: '100%', mt: 2 }}
            />
          </>
        );
      default:
        return null;
    }
  };

  return (
    <Container maxWidth="md" sx={{ py: 8 }}>
      <Grid container spacing={4}>
        {/* Left Side - Registration Form */}
        <Grid item xs={12} md={7}>
          <StyledPaper elevation={3}>
            <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
              Create Account
            </Typography>
            <Typography variant="body1" color="text.secondary" gutterBottom align="center">
              Join us to start shopping
            </Typography>

            <Stepper activeStep={activeStep} sx={{ width: '100%', my: 4 }} alternativeLabel>
              {steps.map((label) => (
                <Step key={label}>
                  <StepLabel>{label}</StepLabel>
                </Step>
              ))}
            </Stepper>

            {error && (
              <Alert severity="error" sx={{ width: '100%', mb: 3 }}>
                {error}
              </Alert>
            )}

            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
              {renderStepContent(activeStep)}

              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
                <Button
                  onClick={handleBack}
                  disabled={activeStep === 0}
                  sx={{ visibility: activeStep === 0 ? 'hidden' : 'visible' }}
                >
                  Back
                </Button>
                {activeStep === steps.length - 1 ? (
                  <Button
                    type="submit"
                    variant="contained"
                    color="primary"
                    disabled={isLoading || !formData.agreeToTerms}
                    sx={{ py: 1, px: 4 }}
                  >
                    {isLoading ? <CircularProgress size={24} /> : 'Create Account'}
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={handleNext}
                    sx={{ py: 1, px: 4 }}
                  >
                    Next
                  </Button>
                )}
              </Box>
            </Box>

            {activeStep === 0 && (
              <>
                <Divider sx={{ width: '100%', my: 3 }}>
                  <Typography variant="body2" color="text.secondary">
                    OR
                  </Typography>
                </Divider>

                <Box sx={{ width: '100%' }}>
                  <SocialButton
                    variant="outlined"
                    startIcon={<Google />}
                    onClick={() => {
                      // In a real app, this would integrate with Google OAuth
                      setError('Social login is not implemented in this demo');
                    }}
                  >
                    Continue with Google
                  </SocialButton>
                  <SocialButton
                    variant="outlined"
                    startIcon={<Facebook />}
                    onClick={() => {
                      setError('Social login is not implemented in this demo');
                    }}
                  >
                    Continue with Facebook
                  </SocialButton>
                  <SocialButton
                    variant="outlined"
                    startIcon={<Apple />}
                    onClick={() => {
                      setError('Social login is not implemented in this demo');
                    }}
                  >
                    Continue with Apple
                  </SocialButton>
                </Box>
              </>
            )}

            <Box sx={{ textAlign: 'center', mt: 3 }}>
              <Typography variant="body2">
                Already have an account?{' '}
                <Link
                  component={RouterLink}
                  to="/login"
                  variant="body2"
                  color="primary.main"
                  fontWeight="bold"
                >
                  Sign In
                </Link>
              </Typography>
            </Box>
          </StyledPaper>
        </Grid>

        {/* Right Side - Benefits */}
        <Grid
          item
          xs={12}
          md={5}
          sx={{
            display: { xs: 'none', md: 'flex' },
            position: 'relative',
          }}
        >
          <Paper
            sx={{
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              padding: 4,
              backgroundColor: 'primary.main',
              color: 'primary.contrastText',
              backgroundImage: 'linear-gradient(135deg, #1976d2 0%, #1565c0 100%)',
              borderRadius: 2,
              boxShadow: 4,
            }}
          >
            <Typography variant="h4" gutterBottom fontWeight="bold">
              Join Our Community
            </Typography>
            <Typography variant="body1" paragraph>
              Create an account to enjoy all the benefits of our store.
            </Typography>

            <Box sx={{ mt: 4 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Fast Checkout</Typography>
                  <Typography variant="body2">
                    Save your details for a quick and easy checkout experience.
                  </Typography>
                </Box>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Order Tracking</Typography>
                  <Typography variant="body2">
                    Track your orders and view your order history anytime.
                  </Typography>
                </Box>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Exclusive Offers</Typography>
                  <Typography variant="body2">
                    Receive personalized offers and promotions just for members.
                  </Typography>
                </Box>
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <CheckCircle sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">Wishlist</Typography>
                  <Typography variant="body2">
                    Save your favorite items to purchase later.
                  </Typography>
                </Box>
              </Box>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
};

export default RegisterPage;

import React, { useState } from 'react';
import { useNavigate, useLocation, Link as RouterLink } from 'react-router-dom';
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Grid,
  Link,
  Paper,
  Divider,
  InputAdornment,
  IconButton,
  Alert,
  CircularProgress,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  Email,
  Lock,
  Visibility,
  VisibilityOff,
  Google,
  Facebook,
  Apple,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useAuth } from '../contexts/AuthContext';

interface LocationState {
  from?: string;
}

const StyledPaper = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(4),
  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(6),
  },
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const SocialButton = styled(Button)(({ theme }) => ({
  width: '100%',
  marginBottom: theme.spacing(2),
  padding: theme.spacing(1.5),
  borderRadius: theme.shape.borderRadius,
  textTransform: 'none',
  fontWeight: 500,
}));

const LoginPage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const location = useLocation();
  const { login } = useAuth();
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const locationState = location.state as LocationState;
  const from = locationState?.from || '/';

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!email || !password) {
      setError('Please enter both email and password');
      return;
    }
    
    try {
      setError('');
      setIsLoading(true);
      await login(email, password);
      navigate(from);
    } catch (error: any) {
      setError(error.message || 'Failed to login. Please check your credentials.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container maxWidth="md" sx={{ py: 8 }}>
      <Grid container spacing={4} alignItems="stretch">
        {/* Left Side - Login Form */}
        <Grid item xs={12} md={6}>
          <StyledPaper elevation={3}>
            <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
              Welcome Back
            </Typography>
            <Typography variant="body1" color="text.secondary" gutterBottom align="center">
              Sign in to your account to continue
            </Typography>

            {error && (
              <Alert severity="error" sx={{ width: '100%', mt: 2, mb: 2 }}>
                {error}
              </Alert>
            )}

            {from !== '/' && (
              <Alert severity="info" sx={{ width: '100%', mt: 2, mb: 2 }}>
                Please login to continue to {from.replace('/', '')}
              </Alert>
            )}

            <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3, width: '100%' }}>
              <TextField
                margin="normal"
                required
                fullWidth
                id="email"
                label="Email Address"
                name="email"
                autoComplete="email"
                autoFocus
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Email color="action" />
                    </InputAdornment>
                  ),
                }}
              />
              <TextField
                margin="normal"
                required
                fullWidth
                name="password"
                label="Password"
                type={showPassword ? 'text' : 'password'}
                id="password"
                autoComplete="current-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Lock color="action" />
                    </InputAdornment>
                  ),
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        aria-label="toggle password visibility"
                        onClick={() => setShowPassword(!showPassword)}
                        edge="end"
                      >
                        {showPassword ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
              <Box sx={{ textAlign: 'right', mt: 1 }}>
                <Link
                  component={RouterLink}
                  to="/forgot-password"
                  variant="body2"
                  color="primary.main"
                >
                  Forgot password?
                </Link>
              </Box>
              <Button
                type="submit"
                fullWidth
                variant="contained"
                color="primary"
                size="large"
                sx={{ mt: 3, mb: 2, py: 1.5 }}
                disabled={isLoading}
              >
                {isLoading ? <CircularProgress size={24} /> : 'Sign In'}
              </Button>
              <Box sx={{ textAlign: 'center', mt: 2 }}>
                <Typography variant="body2">
                  Don't have an account?{' '}
                  <Link
                    component={RouterLink}
                    to="/register"
                    variant="body2"
                    color="primary.main"
                    fontWeight="bold"
                  >
                    Sign Up
                  </Link>
                </Typography>
              </Box>
            </Box>

            <Divider sx={{ width: '100%', my: 3 }}>
              <Typography variant="body2" color="text.secondary">
                OR
              </Typography>
            </Divider>

            <Box sx={{ width: '100%' }}>
              <SocialButton
                variant="outlined"
                startIcon={<Google />}
                onClick={() => {
                  // In a real app, this would integrate with Google OAuth
                  setError('Social login is not implemented in this demo');
                }}
              >
                Continue with Google
              </SocialButton>
              <SocialButton
                variant="outlined"
                startIcon={<Facebook />}
                onClick={() => {
                  setError('Social login is not implemented in this demo');
                }}
              >
                Continue with Facebook
              </SocialButton>
              <SocialButton
                variant="outlined"
                startIcon={<Apple />}
                onClick={() => {
                  setError('Social login is not implemented in this demo');
                }}
              >
                Continue with Apple
              </SocialButton>
            </Box>
          </StyledPaper>
        </Grid>

        {/* Right Side - Image and Info */}
        <Grid
          item
          xs={12}
          md={6}
          sx={{
            display: { xs: 'none', md: 'flex' },
            position: 'relative',
          }}
        >
          <Paper
            sx={{
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              padding: 4,
              backgroundColor: 'primary.main',
              color: 'primary.contrastText',
              backgroundImage: 'linear-gradient(135deg, #1976d2 0%, #1565c0 100%)',
              borderRadius: 2,
              boxShadow: 4,
            }}
          >
            <Typography variant="h4" gutterBottom fontWeight="bold">
              Welcome to Our Store
            </Typography>
            <Typography variant="body1" paragraph align="center">
              Sign in to access your account, track orders, and enjoy a personalized shopping experience.
            </Typography>
            <Box
              sx={{
                mt: 4,
                p: 3,
                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                borderRadius: 2,
                width: '100%',
              }}
            >
              <Typography variant="h6" gutterBottom>
                Benefits of creating an account:
              </Typography>
              <ul style={{ paddingLeft: '20px' }}>
                <li>
                  <Typography variant="body2" paragraph>
                    Fast checkout process
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2" paragraph>
                    Save multiple shipping addresses
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2" paragraph>
                    Access your order history
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2" paragraph>
                    Track your orders easily
                  </Typography>
                </li>
                <li>
                  <Typography variant="body2">
                    Receive exclusive offers and discounts
                  </Typography>
                </li>
              </ul>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
};

export default LoginPage;

import React from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Grid,
  Button,
  Divider,
  Paper,
  IconButton,
  TextField,
  Card,
  CardMedia,
  CardContent,
  List,
  ListItem,
  ListItemText,
  Chip,
  Alert,
  CircularProgress,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  Add,
  Remove,
  Delete,
  ShoppingCart,
  KeyboardBackspace,
  ShoppingBag,
  LocalShipping,
  Payment,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { useCart } from '../contexts/CartContext';
import { useAuth } from '../contexts/AuthContext';

const CartItemCard = styled(Paper)(({ theme }) => ({
  display: 'flex',
  marginBottom: theme.spacing(2),
  padding: theme.spacing(2),
  [theme.breakpoints.down('sm')]: {
    flexDirection: 'column',
  },
}));

const ProductImage = styled(CardMedia)(({ theme }) => ({
  width: 100,
  height: 100,
  objectFit: 'contain',
  marginRight: theme.spacing(2),
  backgroundColor: '#f5f5f5',
  borderRadius: theme.shape.borderRadius,
  [theme.breakpoints.down('sm')]: {
    width: '100%',
    height: 200,
    marginRight: 0,
    marginBottom: theme.spacing(2),
  },
}));

const QuantityControl = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  border: `1px solid ${theme.palette.divider}`,
  borderRadius: theme.shape.borderRadius,
  width: 'fit-content',
}));

const QuantityButton = styled(IconButton)(({ theme }) => ({
  padding: theme.spacing(0.5),
}));

const QuantityInput = styled(TextField)({
  '& .MuiInputBase-input': {
    textAlign: 'center',
    width: '40px',
    padding: '8px 0',
  },
  '& .MuiOutlinedInput-notchedOutline': {
    border: 'none',
  },
});

const OrderSummary = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(3),
  position: 'sticky',
  top: theme.spacing(2),
}));

const CartPage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const { items, itemCount, total, isLoading, updateQuantity, removeFromCart } = useCart();
  const { isAuthenticated } = useAuth();

  const handleQuantityChange = (productId: string, quantity: number) => {
    updateQuantity(productId, quantity);
  };

  const handleRemoveItem = (productId: string) => {
    removeFromCart(productId);
  };

  const handleCheckout = () => {
    if (!isAuthenticated) {
      navigate('/login', { state: { from: '/checkout' } });
    } else {
      navigate('/checkout');
    }
  };

  if (isLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="60vh">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom fontWeight="bold">
        Shopping Cart
      </Typography>

      {items.length === 0 ? (
        <Box textAlign="center" py={8}>
          <ShoppingCart sx={{ fontSize: 80, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h5" gutterBottom>
            Your cart is empty
          </Typography>
          <Typography variant="body1" color="text.secondary" paragraph>
            Looks like you haven't added any products to your cart yet.
          </Typography>
          <Button
            variant="contained"
            color="primary"
            size="large"
            startIcon={<KeyboardBackspace />}
            onClick={() => navigate('/products')}
            sx={{ mt: 2 }}
          >
            Continue Shopping
          </Button>
        </Box>
      ) : (
        <Grid container spacing={4}>
          {/* Cart Items */}
          <Grid item xs={12} md={8}>
            {items.map((item) => (
              <CartItemCard key={item.id} elevation={1}>
                <ProductImage
                  component="img"
                  image={item.imageUrl || '/placeholder-product.png'}
                  alt={item.name}
                  onClick={() => navigate(`/products/${item.id}`)}
                  sx={{ cursor: 'pointer' }}
                />
                <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                  <Box
                    sx={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'flex-start',
                      mb: 1,
                    }}
                  >
                    <Box>
                      <Typography
                        variant="h6"
                        component={RouterLink}
                        to={`/products/${item.id}`}
                        sx={{
                          textDecoration: 'none',
                          color: 'text.primary',
                          '&:hover': { color: 'primary.main' },
                        }}
                      >
                        {item.name}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        Category: {item.category}
                      </Typography>
                      {item.stock < 10 && (
                        <Chip
                          label={`Only ${item.stock} left`}
                          size="small"
                          color="warning"
                          sx={{ mt: 1 }}
                        />
                      )}
                    </Box>
                    <Typography variant="h6" color="primary.main" fontWeight="bold">
                      ${item.price.toFixed(2)}
                    </Typography>
                  </Box>

                  <Box
                    sx={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      mt: 'auto',
                      pt: 1,
                    }}
                  >
                    <QuantityControl>
                      <QuantityButton
                        onClick={() => handleQuantityChange(item.id, item.quantity - 1)}
                        disabled={item.quantity <= 1}
                      >
                        <Remove fontSize="small" />
                      </QuantityButton>
                      <QuantityInput
                        value={item.quantity}
                        onChange={(e) => {
                          const value = parseInt(e.target.value);
                          if (!isNaN(value) && value > 0 && value <= item.stock) {
                            handleQuantityChange(item.id, value);
                          }
                        }}
                        inputProps={{
                          min: 1,
                          max: item.stock,
                          type: 'number',
                        }}
                        variant="outlined"
                        size="small"
                      />
                      <QuantityButton
                        onClick={() => handleQuantityChange(item.id, item.quantity + 1)}
                        disabled={item.quantity >= item.stock}
                      >
                        <Add fontSize="small" />
                      </QuantityButton>
                    </QuantityControl>
                    <IconButton
                      color="error"
                      onClick={() => handleRemoveItem(item.id)}
                      aria-label="Remove item"
                    >
                      <Delete />
                    </IconButton>
                  </Box>
                </Box>
              </CartItemCard>
            ))}

            <Box
              sx={{
                display: 'flex',
                justifyContent: 'space-between',
                mt: 2,
                mb: 4,
              }}
            >
              <Button
                startIcon={<KeyboardBackspace />}
                onClick={() => navigate(-1)}
                sx={{ textTransform: 'none' }}
              >
                Continue Shopping
              </Button>
              <Button
                variant="outlined"
                color="error"
                onClick={() => navigate('/cart/clear')}
                sx={{ textTransform: 'none' }}
              >
                Clear Cart
              </Button>
            </Box>
          </Grid>

          {/* Order Summary */}
          <Grid item xs={12} md={4}>
            <OrderSummary elevation={3}>
              <Typography variant="h6" gutterBottom fontWeight="bold">
                Order Summary
              </Typography>
              <Divider sx={{ mb: 2 }} />

              <List disablePadding>
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Subtotal" />
                  <Typography variant="body1">${total.toFixed(2)}</Typography>
                </ListItem>
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Shipping" />
                  <Typography variant="body1">
                    {total > 100 ? 'Free' : '$10.00'}
                  </Typography>
                </ListItem>
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Tax (10%)" />
                  <Typography variant="body1">
                    ${(total * 0.1).toFixed(2)}
                  </Typography>
                </ListItem>
                <Divider sx={{ my: 1 }} />
                <ListItem sx={{ py: 1, px: 0 }}>
                  <ListItemText primary="Total" />
                  <Typography variant="h6" fontWeight="bold">
                    $
                    {(
                      total +
                      (total > 100 ? 0 : 10) +
                      total * 0.1
                    ).toFixed(2)}
                  </Typography>
                </ListItem>
              </List>

              <Button
                variant="contained"
                color="primary"
                fullWidth
                size="large"
                onClick={handleCheckout}
                sx={{ mt: 3 }}
              >
                Proceed to Checkout
              </Button>

              {!isAuthenticated && (
                <Alert severity="info" sx={{ mt: 2 }}>
                  Please <RouterLink to="/login">login</RouterLink> to complete
                  your purchase
                </Alert>
              )}

              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom>
                  We Accept
                </Typography>
                <Box
                  sx={{
                    display: 'flex',
                    gap: 1,
                    flexWrap: 'wrap',
                  }}
                >
                  {['Visa', 'Mastercard', 'Amex', 'PayPal'].map((method) => (
                    <Chip
                      key={method}
                      label={method}
                      variant="outlined"
                      size="small"
                    />
                  ))}
                </Box>
              </Box>
            </OrderSummary>
          </Grid>
        </Grid>
      )}

      {/* Features */}
      <Grid container spacing={3} sx={{ mt: 6 }}>
        <Grid item xs={12} sm={4}>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexDirection: 'column',
              textAlign: 'center',
              p: 2,
            }}
          >
            <LocalShipping
              color="primary"
              sx={{ fontSize: 40, mb: 1 }}
            />
            <Typography variant="h6" gutterBottom>
              Free Shipping
            </Typography>
            <Typography variant="body2" color="text.secondary">
              On orders over $100
            </Typography>
          </Box>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexDirection: 'column',
              textAlign: 'center',
              p: 2,
            }}
          >
            <ShoppingBag
              color="primary"
              sx={{ fontSize: 40, mb: 1 }}
            />
            <Typography variant="h6" gutterBottom>
              Easy Returns
            </Typography>
            <Typography variant="body2" color="text.secondary">
              30-day return policy
            </Typography>
          </Box>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexDirection: 'column',
              textAlign: 'center',
              p: 2,
            }}
          >
            <Payment
              color="primary"
              sx={{ fontSize: 40, mb: 1 }}
            />
            <Typography variant="h6" gutterBottom>
              Secure Payment
            </Typography>
            <Typography variant="body2" color="text.secondary">
              100% secure checkout
            </Typography>
          </Box>
        </Grid>
      </Grid>
    </Container>
  );
};

export default CartPage;

import React, { useEffect, useState } from 'react';
import { useQuery } from 'react-query';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Button,
  Grid,
  Card,
  CardContent,
  CardMedia,
  CardActions,
  Chip,
  CircularProgress,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  ShoppingCart,
  FavoriteBorder,
  ArrowForward,
  Star,
  FlashOn,
  LocalShipping,
  Security,
  Refresh,
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { Swiper, SwiperSlide } from 'swiper/react';
import { Autoplay, Pagination, Navigation } from 'swiper/modules';
import 'swiper/css';
import 'swiper/css/pagination';
import 'swiper/css/navigation';
import { productApi, Product } from '../services/api';
import { useCart } from '../contexts/CartContext';
import { ProductCard } from '../components/ProductCard';

const HeroSection = styled('section')(({ theme }) => ({
  position: 'relative',
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  padding: theme.spacing(8, 0),
  marginBottom: theme.spacing(6),
  overflow: 'hidden',
}));

const HeroContent = styled(Container)({
  position: 'relative',
  zIndex: 1,
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'flex-start',
  justifyContent: 'center',
  height: '100%',
  padding: '4rem 0',
});

const HeroTitle = styled(Typography)(({ theme }) => ({
  fontWeight: 700,
  marginBottom: theme.spacing(2),
  [theme.breakpoints.up('md')]: {
    fontSize: '3.5rem',
    lineHeight: 1.1,
  },
}));

const HeroSubtitle = styled(Typography)(({ theme }) => ({
  marginBottom: theme.spacing(4),
  maxWidth: '600px',
  opacity: 0.9,
  [theme.breakpoints.up('md')]: {
    fontSize: '1.25rem',
  },
}));

const FeatureCard = styled(Card)(({ theme }) => ({
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  textAlign: 'center',
  padding: theme.spacing(4, 2),
  transition: 'transform 0.3s, box-shadow 0.3s',
  '&:hover': {
    transform: 'translateY(-5px)',
    boxShadow: theme.shadows[8],
  },
}));

const FeatureIcon = styled(Box)(({ theme }) => ({
  width: 60,
  height: 60,
  borderRadius: '50%',
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: theme.spacing(2),
  '& svg': {
    fontSize: '2rem',
  },
}));

const SectionTitle = styled(Typography)(({ theme }) => ({
  position: 'relative',
  display: 'inline-block',
  marginBottom: theme.spacing(4),
  fontWeight: 700,
  '&:after': {
    content: '""',
    position: 'absolute',
    bottom: -8,
    left: 0,
    width: '50%',
    height: 4,
    backgroundColor: theme.palette.primary.main,
    borderRadius: 2,
  },
}));

const HomePage: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();
  const { addToCart } = useCart();

  // Fetch featured products
  const {
    data: featuredProducts = [],
    isLoading: isLoadingFeatured,
  } = useQuery<Product[]>('featuredProducts', () =>
    productApi.getProducts({ featured: true, limit: 8 })
  );

  // Fetch new arrivals
  const {
    data: newArrivals = [],
    isLoading: isLoadingNewArrivals,
  } = useQuery<Product[]>('newArrivals', () =>
    productApi.getProducts({ sort: 'newest', limit: 8 })
  );

  // Fetch best sellers
  const {
    data: bestSellers = [],
    isLoading: isLoadingBestSellers,
  } = useQuery<Product[]>('bestSellers', () =>
    productApi.getProducts({ sort: 'bestseller', limit: 8 })
  );

  const handleAddToCart = (productId: string) => {
    addToCart(productId);
  };

  const features = [
    {
      icon: <LocalShipping />,
      title: 'Free Shipping',
      description: 'On all orders over $50',
    },
    {
      icon: <Refresh />,
      title: 'Easy Returns',
      description: '30-day return policy',
    },
    {
      icon: <Security />,
      title: 'Secure Payment',
      description: '100% secure payment',
    },
    {
      icon: <FlashOn />,
      title: 'Fast Delivery',
      description: 'Same day shipping',
    },
  ];

  const heroSlides = [
    {
      title: 'Summer Collection 2024',
      subtitle: 'Discover our new arrivals with up to 30% off',
      image: '/images/hero-1.jpg',
      buttonText: 'Shop Now',
      buttonVariant: 'contained' as const,
    },
    {
      title: 'Limited Time Offer',
      subtitle: 'Get 50% off on selected items',
      image: '/images/hero-2.jpg',
      buttonText: 'View Deals',
      buttonVariant: 'outlined' as const,
    },
    {
      title: 'New Tech Gadgets',
      subtitle: 'The latest tech at unbeatable prices',
      image: '/images/hero-3.jpg',
      buttonText: 'Explore',
      buttonVariant: 'contained' as const,
    },
  ];

  return (
    <Box sx={{ pb: 6 }}>
      {/* Hero Slider */}
      <Box sx={{ mb: 8 }}>
        <Swiper
          spaceBetween={0}
          centeredSlides={true}
          autoplay={{
            delay: 5000,
            disableOnInteraction: false,
          }}
          pagination={{
            clickable: true,
          }}
          navigation={!isMobile}
          modules={[Autoplay, Pagination, Navigation]}
          style={{
            '--swiper-pagination-color': theme.palette.primary.main,
            '--swiper-navigation-color': theme.palette.primary.main,
          }}
        >
          {heroSlides.map((slide, index) => (
            <SwiperSlide key={index}>
              <HeroSection>
                <HeroContent>
                  <Box sx={{ maxWidth: '600px' }}>
                    <Chip
                      label="New Arrival"
                      color="secondary"
                      size="small"
                      sx={{ mb: 2, fontWeight: 600 }}
                    />
                    <HeroTitle variant="h2" component="h1">
                      {slide.title}
                    </HeroTitle>
                    <HeroSubtitle variant="h5">
                      {slide.subtitle}
                    </HeroSubtitle>
                    <Button
                      variant={slide.buttonVariant}
                      color={slide.buttonVariant === 'contained' ? 'secondary' : 'primary'}
                      size="large"
                      endIcon={<ArrowForward />}
                      onClick={() => navigate('/products')}
                      sx={{
                        borderRadius: '50px',
                        px: 4,
                        py: 1.5,
                        fontWeight: 600,
                      }}
                    >
                      {slide.buttonText}
                    </Button>
                  </Box>
                </HeroContent>
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: '50%',
                    backgroundImage: `url(${slide.image})`,
                    backgroundSize: 'cover',
                    backgroundPosition: 'center',
                    opacity: 0.1,
                    [theme.breakpoints.up('md')]: {
                      opacity: 1,
                      backgroundPosition: 'right',
                    },
                  }}
                />
              </HeroSection>
            </SwiperSlide>
          ))}
        </Swiper>
      </Box>

      {/* Features */}
      <Container maxWidth="lg" sx={{ mb: 8 }}>
        <Grid container spacing={3}>
          {features.map((feature, index) => (
            <Grid item xs={12} sm={6} md={3} key={index}>
              <FeatureCard elevation={2}>
                <FeatureIcon>{feature.icon}</FeatureIcon>
                <Typography variant="h6" component="h3" gutterBottom>
                  {feature.title}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {feature.description}
                </Typography>
              </FeatureCard>
            </Grid>
          ))}
        </Grid>
      </Container>

      {/* Featured Products */}
      <Container maxWidth="lg" sx={{ mb: 8 }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 4,
          }}
        >
          <SectionTitle variant="h4" component="h2">
            Featured Products
          </SectionTitle>
          <Button
            endIcon={<ArrowForward />}
            onClick={() => navigate('/products?filter=featured')}
          >
            View All
          </Button>
        </Box>

        {isLoadingFeatured ? (
          <Box display="flex" justifyContent="center" my={8}>
            <CircularProgress />
          </Box>
        ) : (
          <Grid container spacing={3}>
            {featuredProducts.map((product) => (
              <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
                <ProductCard
                  product={product}
                  onAddToCart={handleAddToCart}
                />
              </Grid>
            ))}
          </Grid>
        )}
      </Container>

      {/* New Arrivals */}
      <Box bgcolor="background.paper" py={8}>
        <Container maxWidth="lg">
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              mb: 4,
            }}
          >
            <SectionTitle variant="h4" component="h2">
              New Arrivals
            </SectionTitle>
            <Button
              endIcon={<ArrowForward />}
              onClick={() => navigate('/products?sort=newest')}
            >
              View All
            </Button>
          </Box>

          {isLoadingNewArrivals ? (
            <Box display="flex" justifyContent="center" my={8}>
              <CircularProgress />
            </Box>
          ) : (
            <Grid container spacing={3}>
              {newArrivals.map((product) => (
                <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
                  <ProductCard
                    product={product}
                    onAddToCart={handleAddToCart}
                  />
                </Grid>
              ))}
            </Grid>
          )}
        </Container>
      </Box>

      {/* Best Sellers */}
      <Container maxWidth="lg" sx={{ my: 8 }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mb: 4,
          }}
        >
          <SectionTitle variant="h4" component="h2">
            Best Sellers
          </SectionTitle>
          <Button
            endIcon={<ArrowForward />}
            onClick={() => navigate('/products?sort=bestseller')}
          >
            View All
          </Button>
        </Box>

        {isLoadingBestSellers ? (
          <Box display="flex" justifyContent="center" my={8}>
            <CircularProgress />
          </Box>
        ) : (
          <Grid container spacing={3}>
            {bestSellers.map((product) => (
              <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
                <ProductCard
                  product={product}
                  onAddToCart={handleAddToCart}
                />
              </Grid>
            ))}
          </Grid>
        )}
      </Container>

      {/* Newsletter Section */}
      <Box bgcolor="primary.main" color="primary.contrastText" py={8}>
        <Container maxWidth="md">
          <Box textAlign="center">
            <Typography variant="h4" component="h2" gutterBottom fontWeight="bold">
              Subscribe to Our Newsletter
            </Typography>
            <Typography variant="body1" mb={4} maxWidth="600px" mx="auto">
              Stay updated with our latest products, promotions, and news. Subscribe to
              our newsletter today!
            </Typography>
            <Box
              component="form"
              sx={{
                display: 'flex',
                maxWidth: '500px',
                mx: 'auto',
                '& .MuiOutlinedInput-root': {
                  backgroundColor: 'background.paper',
                },
              }}
            >
              <input
                type="email"
                placeholder="Enter your email"
                style={{
                  flex: 1,
                  padding: '12px 16px',
                  border: 'none',
                  borderRadius: '4px 0 0 4px',
                  fontSize: '1rem',
                  outline: 'none',
                }}
                required
              />
              <Button
                type="submit"
                variant="contained"
                color="secondary"
                sx={{
                  borderRadius: '0 4px 4px 0',
                  px: 4,
                  py: '12px',
                  fontWeight: 600,
                }}
              >
                Subscribe
              </Button>
            </Box>
          </Box>
        </Container>
      </Box>
    </Box>
  );
};

export default HomePage;

import axios from 'axios';
import { Product, Review, Order, User, CartItem } from '../types/product';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor to include auth token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const productApi = {
  getProducts: async (params?: { category?: string; search?: string; sort?: string }) => {
    const response = await api.get<Product[]>('/products', { params });
    return response.data;
  },
  
  getProductById: async (id: string) => {
    const response = await api.get<Product>(`/products/${id}`);
    return response.data;
  },
  
  createProduct: async (product: Omit<Product, 'id' | 'reviews' | 'rating'>) => {
    const response = await api.post<Product>('/products', product);
    return response.data;
  },
  
  updateProduct: async (id: string, updates: Partial<Product>) => {
    const response = await api.put<Product>(`/products/${id}`, updates);
    return response.data;
  },
  
  deleteProduct: async (id: string) => {
    await api.delete(`/products/${id}`);
  },
  
  addReview: async (productId: string, review: Omit<Review, 'id' | 'date'>) => {
    const response = await api.post<Review>(`/products/${productId}/reviews`, review);
    return response.data;
  },
};

export const cartApi = {
  getCart: async () => {
    const response = await api.get<CartItem[]>('/cart');
    return response.data;
  },
  
  addToCart: async (productId: string, quantity: number = 1) => {
    const response = await api.post<CartItem>('/cart/items', { productId, quantity });
    return response.data;
  },
  
  updateCartItem: async (productId: string, quantity: number) => {
    const response = await api.put<CartItem>(`/cart/items/${productId}`, { quantity });
    return response.data;
  },
  
  removeFromCart: async (productId: string) => {
    await api.delete(`/cart/items/${productId}`);
  },
  
  clearCart: async () => {
    await api.delete('/cart');
  },
};

export const orderApi = {
  getOrders: async () => {
    const response = await api.get<Order[]>('/orders');
    return response.data;
  },
  
  getOrderById: async (id: string) => {
    const response = await api.get<Order>(`/orders/${id}`);
    return response.data;
  },
  
  createOrder: async (orderData: {
    items: Array<{ productId: string; quantity: number }>;
    shippingAddress: {
      street: string;
      city: string;
      state: string;
      zipCode: string;
      country: string;
    };
    paymentMethod: string;
  }) => {
    const response = await api.post<Order>('/orders', orderData);
    return response.data;
  },
};

export const authApi = {
  login: async (credentials: { email: string; password: string }) => {
    const response = await api.post<{ token: string; user: User }>('/auth/login', credentials);
    return response.data;
  },
  
  register: async (userData: {
    name: string;
    email: string;
    password: string;
  }) => {
    const response = await api.post<{ token: string; user: User }>('/auth/register', userData);
    return response.data;
  },
  
  getCurrentUser: async () => {
    const response = await api.get<User>('/auth/me');
    return response.data;
  },
  
  updateProfile: async (updates: Partial<User>) => {
    const response = await api.put<User>('/auth/profile', updates);
    return response.data;
  },
};

{"name": "ecommerce-backend", "version": "1.0.0", "description": "Node.js backend for e-commerce application", "main": "dist/index.js", "scripts": {"start": "node dist/index.js", "dev": "nodemon src/index.ts", "build": "tsc", "test": "jest", "lint": "eslint src/**/*.ts", "format": "prettier --write \"src/**/*.ts\""}, "dependencies": {"bcryptjs": "^2.4.3", "cors": "^2.8.5", "dotenv": "^16.0.3", "express": "^4.18.2", "express-validator": "^7.0.1", "jsonwebtoken": "^9.0.0", "mongoose": "^7.1.0", "morgan": "^1.10.0", "multer": "^1.4.5-lts.1", "stripe": "^12.3.0", "winston": "^3.8.2"}, "devDependencies": {"@types/bcryptjs": "^2.4.2", "@types/cors": "^2.8.13", "@types/express": "^4.17.17", "@types/jest": "^29.5.1", "@types/jsonwebtoken": "^9.0.2", "@types/morgan": "^1.9.4", "@types/multer": "^1.4.7", "@types/node": "^18.16.3", "@types/supertest": "^2.0.12", "@typescript-eslint/eslint-plugin": "^5.59.2", "@typescript-eslint/parser": "^5.59.2", "eslint": "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", "jest": "^29.5.0", "nodemon": "^2.0.22", "prettier": "^2.8.8", "supertest": "^6.3.3", "ts-jest": "^29.1.0", "ts-node": "^10.9.1", "typescript": "^5.0.4"}, "engines": {"node": ">=14.0.0"}}
{"compilerOptions": {"target": "es2018", "module": "commonjs", "outDir": "./dist", "rootDir": "./src", "strict": true, "esModuleInterop": true, "skipLibCheck": true, "forceConsistentCasingInFileNames": true, "resolveJsonModule": true, "sourceMap": true, "declaration": true, "removeComments": true, "typeRoots": ["./node_modules/@types", "./src/types"], "baseUrl": "./src", "paths": {"@/*": ["*"]}}, "include": ["src/**/*"], "exclude": ["node_modules", "**/*.test.ts", "dist"]}
import express, { Express, Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import morgan from 'morgan';
import dotenv from 'dotenv';
import path from 'path';

// Import routes
import authRoutes from './routes/auth.routes';
import productRoutes from './routes/product.routes';
import cartRoutes from './routes/cart.routes';
import orderRoutes from './routes/order.routes';
import userRoutes from './routes/user.routes';
import categoryRoutes from './routes/category.routes';
import reviewRoutes from './routes/review.routes';

// Import middleware
import { errorHandler } from './middleware/error.middleware';
import { authMiddleware } from './middleware/auth.middleware';

// Load environment variables
dotenv.config();

// Initialize Express app
const app: Express = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('dev'));

// Static files
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/products', productRoutes);
app.use('/api/cart', authMiddleware, cartRoutes);
app.use('/api/orders', authMiddleware, orderRoutes);
app.use('/api/users', authMiddleware, userRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/reviews', reviewRoutes);

// Health check endpoint
app.get('/health', (req: Request, res: Response) => {
  res.status(200).json({ status: 'ok', message: 'Server is running' });
});

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({ message: 'Route not found' });
});

// Error handling middleware
app.use(errorHandler);

// Connect to MongoDB and start server
const startServer = async () => {
  try {
    const mongoUri = process.env.MONGO_URI || 'mongodb://localhost:27017/ecommerce';
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');

    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to connect to MongoDB', error);
    process.exit(1);
  }
};

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (error) => {
  console.error('Unhandled Rejection:', error);
  process.exit(1);
});

// Start the server
startServer();

import { Request, Response, NextFunction } from 'express';

interface AppError extends Error {
  statusCode?: number;
  errors?: any[];
  code?: number;
}

export const errorHandler = (
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error('Error:', err);

  // Default error status and message
  let statusCode = err.statusCode || 500;
  let message = err.message || 'Internal Server Error';
  let errors = err.errors || [];

  // Handle mongoose validation errors
  if (err.name === 'ValidationError') {
    statusCode = 400;
    message = 'Validation Error';
    errors = Object.values((err as any).errors).map((error: any) => ({
      field: error.path,
      message: error.message,
    }));
  }

  // Handle mongoose duplicate key errors
  if (err.code === 11000) {
    statusCode = 400;
    message = 'Duplicate field value entered';
    
    const field = Object.keys((err as any).keyValue)[0];
    errors = [{ field, message: `${field} already exists` }];
  }

  // Handle mongoose cast errors
  if (err.name === 'CastError') {
    statusCode = 400;
    message = 'Invalid ID format';
    errors = [{ field: (err as any).path, message: 'Invalid format' }];
  }

  // Handle JWT errors
  if (err.name === 'JsonWebTokenError') {
    statusCode = 401;
    message = 'Invalid token';
  }

  if (err.name === 'TokenExpiredError') {
    statusCode = 401;
    message = 'Token expired';
  }

  // Send error response
  res.status(statusCode).json({
    success: false,
    message,
    errors: errors.length > 0 ? errors : undefined,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
  });
};

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models/user.model';

// Extend Express Request interface to include user
declare global {
  namespace Express {
    interface Request {
      user?: any;
    }
  }
}

export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        message: 'Authentication failed. No token provided or invalid format.',
      });
    }

    const token = authHeader.split(' ')[1];
    
    // Verify token
    const decoded: any = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    
    // Find user by id
    const user = await User.findById(decoded.id).select('-password');
    
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }
    
    // Add user to request object
    req.user = user;
    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    res.status(401).json({ message: 'Authentication failed. Invalid token.' });
  }
};

export const adminMiddleware = (req: Request, res: Response, next: NextFunction) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Access denied. Admin privileges required.' });
  }
};

export const optionalAuthMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return next();
    }

    const token = authHeader.split(' ')[1];
    
    const decoded: any = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    const user = await User.findById(decoded.id).select('-password');
    
    if (user) {
      req.user = user;
    }
    
    next();
  } catch (error) {
    // If token is invalid, just continue without setting user
    next();
  }
};

import Stripe from 'stripe';
import logger from './logger';

// Initialize Stripe with API key from environment variables
const stripeSecretKey = process.env.STRIPE_SECRET_KEY || 'dummy_key_for_development';
const stripe = new Stripe(stripeSecretKey, {
  apiVersion: '2023-10-16', // Use the latest API version
});

/**
 * Create a payment intent with Stripe
 * @param amount Amount in cents
 * @param currency Currency code (default: 'usd')
 * @param metadata Additional metadata
 * @returns Payment intent
 */
export const createPaymentIntent = async (
  amount: number,
  currency: string = 'usd',
  metadata: Record<string, string> = {}
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency,
      metadata,
      payment_method_types: ['card'],
    });
    
    logger.info(`Payment intent created: ${paymentIntent.id}`);
    return paymentIntent;
  } catch (error) {
    logger.error('Error creating payment intent:', error);
    throw error;
  }
};

/**
 * Retrieve a payment intent by ID
 * @param paymentIntentId Payment intent ID
 * @returns Payment intent
 */
export const retrievePaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    return paymentIntent;
  } catch (error) {
    logger.error(`Error retrieving payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Confirm a payment intent
 * @param paymentIntentId Payment intent ID
 * @param paymentMethodId Payment method ID
 * @returns Confirmed payment intent
 */
export const confirmPaymentIntent = async (
  paymentIntentId: string,
  paymentMethodId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.confirm(paymentIntentId, {
      payment_method: paymentMethodId,
    });
    
    logger.info(`Payment intent confirmed: ${paymentIntent.id}`);
    return paymentIntent;
  } catch (error) {
    logger.error(`Error confirming payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Cancel a payment intent
 * @param paymentIntentId Payment intent ID
 * @returns Canceled payment intent
 */
export const cancelPaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripe.paymentIntents.cancel(paymentIntentId);
    
    logger.info(`Payment intent canceled: ${paymentIntent.id}`);
    return paymentIntent;
  } catch (error) {
    logger.error(`Error canceling payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Create a refund for a payment intent
 * @param paymentIntentId Payment intent ID
 * @param amount Amount to refund (in cents)
 * @param reason Reason for refund
 * @returns Refund
 */
export const createRefund = async (
  paymentIntentId: string,
  amount?: number,
  reason?: Stripe.RefundCreateParams.Reason
): Promise<Stripe.Refund> => {
  try {
    const refundParams: Stripe.RefundCreateParams = {
      payment_intent: paymentIntentId,
    };
    
    if (amount) {
      refundParams.amount = amount;
    }
    
    if (reason) {
      refundParams.reason = reason;
    }
    
    const refund = await stripe.refunds.create(refundParams);
    
    logger.info(`Refund created: ${refund.id} for payment intent ${paymentIntentId}`);
    return refund;
  } catch (error) {
    logger.error(`Error creating refund for payment intent ${paymentIntentId}:`, error);
    throw error;
  }
};

/**
 * Create a customer in Stripe
 * @param email Customer email
 * @param name Customer name
 * @param metadata Additional metadata
 * @returns Customer
 */
export const createCustomer = async (
  email: string,
  name: string,
  metadata: Record<string, string> = {}
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripe.customers.create({
      email,
      name,
      metadata,
    });
    
    logger.info(`Customer created: ${customer.id}`);
    return customer;
  } catch (error) {
    logger.error('Error creating customer:', error);
    throw error;
  }
};

/**
 * Add a payment method to a customer
 * @param customerId Customer ID
 * @param paymentMethodId Payment method ID
 * @returns Payment method
 */
export const attachPaymentMethod = async (
  customerId: string,
  paymentMethodId: string
): Promise<Stripe.PaymentMethod> => {
  try {
    const paymentMethod = await stripe.paymentMethods.attach(paymentMethodId, {
      customer: customerId,
    });
    
    logger.info(`Payment method ${paymentMethod.id} attached to customer ${customerId}`);
    return paymentMethod;
  } catch (error) {
    logger.error(`Error attaching payment method ${paymentMethodId} to customer ${customerId}:`, error);
    throw error;
  }
};

/**
 * Convert order amount to cents for Stripe
 * @param amount Amount in dollars
 * @returns Amount in cents
 */
export const convertToCents = (amount: number): number => {
  return Math.round(amount * 100);
};

import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { Request } from 'express';
import { v4 as uuidv4 } from 'uuid';

// Define storage locations
const UPLOAD_DIR = path.join(__dirname, '../../uploads');
const PRODUCT_IMAGES_DIR = path.join(UPLOAD_DIR, 'products');
const USER_IMAGES_DIR = path.join(UPLOAD_DIR, 'users');
const CATEGORY_IMAGES_DIR = path.join(UPLOAD_DIR, 'categories');
const TEMP_DIR = path.join(UPLOAD_DIR, 'temp');

// Ensure upload directories exist
[UPLOAD_DIR, PRODUCT_IMAGES_DIR, USER_IMAGES_DIR, CATEGORY_IMAGES_DIR, TEMP_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Define file filter for images
const imageFileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  // Accept only image files
  if (!file.originalname.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
    return cb(new Error('Only image files are allowed!'));
  }
  cb(null, true);
};

// Create storage engine for product images
const productStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, PRODUCT_IMAGES_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create storage engine for user images
const userStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, USER_IMAGES_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create storage engine for category images
const categoryStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, CATEGORY_IMAGES_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create storage engine for temporary uploads
const tempStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, TEMP_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  },
});

// Create multer instances
export const productUpload = multer({
  storage: productStorage,
  fileFilter: imageFileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
});

export const userUpload = multer({
  storage: userStorage,
  fileFilter: imageFileFilter,
  limits: {
    fileSize: 2 * 1024 * 1024, // 2MB
  },
});

export const categoryUpload = multer({
  storage: categoryStorage,
  fileFilter: imageFileFilter,
  limits: {
    fileSize: 3 * 1024 * 1024, // 3MB
  },
});

export const tempUpload = multer({
  storage: tempStorage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
  },
});

/**
 * Move a file from temp directory to target directory
 * @param filename Filename in temp directory
 * @param targetDir Target directory
 * @returns New file path
 */
export const moveFileFromTemp = (filename: string, targetDir: string): string => {
  const sourcePath = path.join(TEMP_DIR, filename);
  const targetPath = path.join(targetDir, filename);
  
  if (!fs.existsSync(sourcePath)) {
    throw new Error(`File ${filename} not found in temp directory`);
  }
  
  fs.copyFileSync(sourcePath, targetPath);
  fs.unlinkSync(sourcePath);
  
  return targetPath;
};

/**
 * Delete a file
 * @param filepath Path to file
 */
export const deleteFile = (filepath: string): void => {
  if (fs.existsSync(filepath)) {
    fs.unlinkSync(filepath);
  }
};

/**
 * Get public URL for a file
 * @param filepath Path to file
 * @returns Public URL
 */
export const getFileUrl = (filepath: string): string => {
  const relativePath = filepath.replace(UPLOAD_DIR, '');
  return `/uploads${relativePath.replace(/\\/g, '/')}`;
};

import winston from 'winston';
import path from 'path';

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Determine log level based on environment
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  return env === 'development' ? 'debug' : 'info';
};

// Define transports
const transports = [
  // Console transport
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.printf(
        (info) => `${info.timestamp} ${info.level}: ${info.message}`
      )
    ),
  }),
  // File transport for errors
  new winston.transports.File({
    filename: path.join(__dirname, '../../logs/error.log'),
    level: 'error',
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),
  // File transport for all logs
  new winston.transports.File({
    filename: path.join(__dirname, '../../logs/combined.log'),
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),
];

// Create logger instance
const logger = winston.createLogger({
  level: level(),
  levels,
  format: logFormat,
  transports,
  exitOnError: false,
});

export default logger;

import { Response } from 'express';

/**
 * Standard API response format
 */
interface ApiResponse<T> {
  success: boolean;
  message?: string;
  data?: T;
  errors?: any[];
  meta?: {
    pagination?: {
      page: number;
      limit: number;
      total: number;
      pages: number;
    };
    [key: string]: any;
  };
}

/**
 * Send a success response
 * @param res Express response object
 * @param data Response data
 * @param message Success message
 * @param statusCode HTTP status code
 * @param meta Additional metadata
 */
export const sendSuccess = <T>(
  res: Response,
  data?: T,
  message: string = 'Success',
  statusCode: number = 200,
  meta?: any
): Response<ApiResponse<T>> => {
  return res.status(statusCode).json({
    success: true,
    message,
    data,
    meta,
  });
};

/**
 * Send an error response
 * @param res Express response object
 * @param message Error message
 * @param statusCode HTTP status code
 * @param errors Array of specific errors
 */
export const sendError = (
  res: Response,
  message: string = 'Error',
  statusCode: number = 400,
  errors?: any[]
): Response<ApiResponse<null>> => {
  return res.status(statusCode).json({
    success: false,
    message,
    errors,
  });
};

/**
 * Send a paginated response
 * @param res Express response object
 * @param data Response data
 * @param page Current page
 * @param limit Items per page
 * @param total Total number of items
 * @param message Success message
 * @param statusCode HTTP status code
 * @param additionalMeta Additional metadata
 */
export const sendPaginated = <T>(
  res: Response,
  data: T,
  page: number,
  limit: number,
  total: number,
  message: string = 'Success',
  statusCode: number = 200,
  additionalMeta?: any
): Response<ApiResponse<T>> => {
  const pages = Math.ceil(total / limit);
  
  return res.status(statusCode).json({
    success: true,
    message,
    data,
    meta: {
      pagination: {
        page,
        limit,
        total,
        pages,
      },
      ...additionalMeta,
    },
  });
};

import { Request, Response, NextFunction } from 'express';
import { validationResult, ValidationChain } from 'express-validator';
import { sendError } from './apiResponse';

/**
 * Middleware to validate request using express-validator
 * @param validations Array of validation chains
 */
export const validate = (validations: ValidationChain[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Run all validations
    await Promise.all(validations.map(validation => validation.run(req)));

    // Check for validation errors
    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }

    // Format errors for response
    const formattedErrors = errors.array().map(error => ({
      field: error.param,
      message: error.msg,
      value: error.value,
    }));

    // Send error response
    return sendError(
      res,
      'Validation Error',
      400,
      formattedErrors
    );
  };
};

/**
 * Helper function to check if a string is a valid MongoDB ObjectId
 * @param id String to validate
 */
export const isValidObjectId = (id: string): boolean => {
  return /^[0-9a-fA-F]{24}$/.test(id);
};

/**
 * Helper function to validate email format
 * @param email Email to validate
 */
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

/**
 * Helper function to validate password strength
 * @param password Password to validate
 */
export const isStrongPassword = (password: string): boolean => {
  // At least 8 characters, one uppercase, one lowercase, one number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  return passwordRegex.test(password);
};

/**
 * Helper function to validate phone number format
 * @param phone Phone number to validate
 */
export const isValidPhone = (phone: string): boolean => {
  const phoneRegex = /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/;
  return phoneRegex.test(phone);
};

/**
 * Helper function to sanitize a string for use in a query
 * @param str String to sanitize
 */
export const sanitizeString = (str: string): string => {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  role: 'user' | 'admin';
  avatar?: string;
  address?: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  phone?: string;
  isVerified: boolean;
  resetPasswordToken?: string;
  resetPasswordExpire?: Date;
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const userSchema = new Schema<IUser>(
  {
    name: {
      type: String,
      required: [true, 'Please provide a name'],
      trim: true,
      maxlength: [50, 'Name cannot be more than 50 characters'],
    },
    email: {
      type: String,
      required: [true, 'Please provide an email'],
      unique: true,
      lowercase: true,
      trim: true,
      match: [
        /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
        'Please provide a valid email',
      ],
    },
    password: {
      type: String,
      required: [true, 'Please provide a password'],
      minlength: [6, 'Password must be at least 6 characters'],
      select: false, // Don't return password in queries
    },
    role: {
      type: String,
      enum: ['user', 'admin'],
      default: 'user',
    },
    avatar: {
      type: String,
    },
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String,
      country: String,
    },
    phone: {
      type: String,
      match: [/^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/, 'Please provide a valid phone number'],
    },
    isVerified: {
      type: Boolean,
      default: false,
    },
    resetPasswordToken: String,
    resetPasswordExpire: Date,
  },
  {
    timestamps: true,
  }
);

// Encrypt password before saving
userSchema.pre('save', async function (next) {
  // Only hash the password if it's modified (or new)
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error: any) {
    next(error);
  }
});

// Method to compare password
userSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export const User = mongoose.model<IUser>('User', userSchema);

import mongoose, { Document, Schema } from 'mongoose';

export interface IOrderItem {
  product: mongoose.Types.ObjectId;
  name: string;
  quantity: number;
  price: number;
  image: string;
}

export interface IShippingAddress {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}

export interface IOrder extends Document {
  user: mongoose.Types.ObjectId;
  orderItems: IOrderItem[];
  shippingAddress: IShippingAddress;
  paymentMethod: string;
  paymentResult?: {
    id: string;
    status: string;
    update_time: string;
    email_address: string;
  };
  itemsPrice: number;
  taxPrice: number;
  shippingPrice: number;
  totalPrice: number;
  isPaid: boolean;
  paidAt?: Date;
  isDelivered: boolean;
  deliveredAt?: Date;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled';
  trackingNumber?: string;
  createdAt: Date;
  updatedAt: Date;
}

const orderItemSchema = new Schema<IOrderItem>({
  product: {
    type: Schema.Types.ObjectId,
    ref: 'Product',
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: [1, 'Quantity must be at least 1'],
  },
  price: {
    type: Number,
    required: true,
    min: [0, 'Price cannot be negative'],
  },
  image: {
    type: String,
    required: true,
  },
});

const shippingAddressSchema = new Schema<IShippingAddress>({
  street: {
    type: String,
    required: [true, 'Street address is required'],
  },
  city: {
    type: String,
    required: [true, 'City is required'],
  },
  state: {
    type: String,
    required: [true, 'State is required'],
  },
  zipCode: {
    type: String,
    required: [true, 'Zip code is required'],
  },
  country: {
    type: String,
    required: [true, 'Country is required'],
  },
});

const orderSchema = new Schema<IOrder>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    orderItems: [orderItemSchema],
    shippingAddress: shippingAddressSchema,
    paymentMethod: {
      type: String,
      required: [true, 'Payment method is required'],
    },
    paymentResult: {
      id: String,
      status: String,
      update_time: String,
      email_address: String,
    },
    itemsPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    taxPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    shippingPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    totalPrice: {
      type: Number,
      required: true,
      min: 0,
    },
    isPaid: {
      type: Boolean,
      default: false,
    },
    paidAt: Date,
    isDelivered: {
      type: Boolean,
      default: false,
    },
    deliveredAt: Date,
    status: {
      type: String,
      enum: ['pending', 'processing', 'shipped', 'delivered', 'cancelled'],
      default: 'pending',
    },
    trackingNumber: String,
  },
  {
    timestamps: true,
  }
);

// Virtual for order age in days
orderSchema.virtual('ageInDays').get(function () {
  return Math.floor(
    (Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24)
  );
});

// Index for faster queries
orderSchema.index({ user: 1, createdAt: -1 });
orderSchema.index({ status: 1 });

export const Order = mongoose.model<IOrder>('Order', orderSchema);

import mongoose, { Document, Schema } from 'mongoose';

export interface ICartItem {
  product: mongoose.Types.ObjectId;
  quantity: number;
  price: number;
  name: string;
  image: string;
}

export interface ICart extends Document {
  user: mongoose.Types.ObjectId;
  items: ICartItem[];
  totalPrice: number;
  createdAt: Date;
  updatedAt: Date;
  calculateTotalPrice(): number;
}

const cartItemSchema = new Schema<ICartItem>({
  product: {
    type: Schema.Types.ObjectId,
    ref: 'Product',
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
    min: [1, 'Quantity must be at least 1'],
  },
  price: {
    type: Number,
    required: true,
    min: [0, 'Price cannot be negative'],
  },
  name: {
    type: String,
    required: true,
  },
  image: {
    type: String,
    required: true,
  },
});

const cartSchema = new Schema<ICart>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      unique: true,
    },
    items: [cartItemSchema],
    totalPrice: {
      type: Number,
      required: true,
      default: 0,
      min: 0,
    },
  },
  {
    timestamps: true,
  }
);

// Calculate total price before saving
cartSchema.pre('save', function (next) {
  this.totalPrice = this.calculateTotalPrice();
  next();
});

// Method to calculate total price
cartSchema.methods.calculateTotalPrice = function (): number {
  return this.items.reduce(
    (total, item) => total + item.price * item.quantity,
    0
  );
};

export const Cart = mongoose.model<ICart>('Cart', cartSchema);

import mongoose, { Document, Schema } from 'mongoose';

export interface IReview {
  user: mongoose.Types.ObjectId;
  name: string;
  rating: number;
  comment: string;
  date: Date;
}

export interface IProduct extends Document {
  name: string;
  description: string;
  shortDescription: string;
  price: number;
  originalPrice?: number;
  images: string[];
  category: string;
  brand: string;
  stock: number;
  rating: number;
  numReviews: number;
  reviews: IReview[];
  sku: string;
  featured: boolean;
  isNew: boolean;
  onSale: boolean;
  tags: string[];
  attributes: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

const reviewSchema = new Schema<IReview>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    name: {
      type: String,
      required: true,
    },
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
    comment: {
      type: String,
      required: true,
    },
    date: {
      type: Date,
      default: Date.now,
    },
  },
  { _id: true }
);

const productSchema = new Schema<IProduct>(
  {
    name: {
      type: String,
      required: [true, 'Please provide a product name'],
      trim: true,
      maxlength: [100, 'Product name cannot be more than 100 characters'],
    },
    description: {
      type: String,
      required: [true, 'Please provide a product description'],
    },
    shortDescription: {
      type: String,
      required: [true, 'Please provide a short description'],
      maxlength: [200, 'Short description cannot be more than 200 characters'],
    },
    price: {
      type: Number,
      required: [true, 'Please provide a product price'],
      min: [0, 'Price cannot be negative'],
    },
    originalPrice: {
      type: Number,
      min: [0, 'Original price cannot be negative'],
    },
    images: [
      {
        type: String,
        required: [true, 'Please provide at least one product image'],
      },
    ],
    category: {
      type: String,
      required: [true, 'Please provide a product category'],
      index: true,
    },
    brand: {
      type: String,
      required: [true, 'Please provide a product brand'],
      index: true,
    },
    stock: {
      type: Number,
      required: [true, 'Please provide product stock'],
      min: [0, 'Stock cannot be negative'],
      default: 0,
    },
    rating: {
      type: Number,
      default: 0,
      min: 0,
      max: 5,
    },
    numReviews: {
      type: Number,
      default: 0,
    },
    reviews: [reviewSchema],
    sku: {
      type: String,
      required: [true, 'Please provide a product SKU'],
      unique: true,
      trim: true,
    },
    featured: {
      type: Boolean,
      default: false,
    },
    isNew: {
      type: Boolean,
      default: false,
    },
    onSale: {
      type: Boolean,
      default: false,
    },
    tags: [
      {
        type: String,
        trim: true,
      },
    ],
    attributes: {
      type: Map,
      of: Schema.Types.Mixed,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Index for search
productSchema.index({ name: 'text', description: 'text', brand: 'text', category: 'text' });

// Calculate average rating when reviews are modified
productSchema.pre('save', function (next) {
  if (this.isModified('reviews')) {
    if (this.reviews.length === 0) {
      this.rating = 0;
      this.numReviews = 0;
    } else {
      this.rating =
        this.reviews.reduce((acc, review) => acc + review.rating, 0) /
        this.reviews.length;
      this.numReviews = this.reviews.length;
    }
  }
  next();
});

export const Product = mongoose.model<IProduct>('Product', productSchema);

import mongoose, { Document, Schema } from 'mongoose';
import slugify from 'slugify';

export interface ICategory extends Document {
  name: string;
  slug: string;
  description?: string;
  image?: string;
  parent?: mongoose.Types.ObjectId;
  level: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const categorySchema = new Schema<ICategory>(
  {
    name: {
      type: String,
      required: [true, 'Category name is required'],
      trim: true,
      unique: true,
      maxlength: [50, 'Category name cannot be more than 50 characters'],
    },
    slug: {
      type: String,
      unique: true,
      lowercase: true,
      index: true,
    },
    description: {
      type: String,
      maxlength: [500, 'Description cannot be more than 500 characters'],
    },
    image: {
      type: String,
    },
    parent: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      default: null,
    },
    level: {
      type: Number,
      default: 1,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual for subcategories
categorySchema.virtual('subcategories', {
  ref: 'Category',
  localField: '_id',
  foreignField: 'parent',
});

// Generate slug before saving
categorySchema.pre('save', function (next) {
  if (this.isModified('name')) {
    this.slug = slugify(this.name, { lower: true });
  }
  
  // Set level based on parent
  if (this.parent) {
    this.level = 2; // For simplicity, we're using just 2 levels
  } else {
    this.level = 1;
  }
  
  next();
});

// Index for faster queries
categorySchema.index({ name: 'text', slug: 'text' });

export const Category = mongoose.model<ICategory>('Category', categorySchema);

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User, IUser } from '../models/user.model';

// Generate JWT token
const generateToken = (id: string): string => {
  return jwt.sign({ id }, process.env.JWT_SECRET || 'secret', {
    expiresIn: process.env.JWT_EXPIRES_IN || '30d',
  });
};

// @desc    Register a new user
// @route   POST /api/auth/register
// @access  Public
export const register = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { name, email, password } = req.body;

    // Check if user already exists
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({
        message: 'User already exists',
      });
    }

    // Create new user
    const user = await User.create({
      name,
      email,
      password,
    });

    // Generate token
    const token = generateToken(user._id.toString());

    res.status(201).json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
export const login = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { email, password } = req.body;

    // Check if email and password are provided
    if (!email || !password) {
      return res.status(400).json({
        message: 'Please provide email and password',
      });
    }

    // Find user by email and include password
    const user = await User.findOne({ email }).select('+password');

    // Check if user exists and password is correct
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({
        message: 'Invalid email or password',
      });
    }

    // Generate token
    const token = generateToken(user._id.toString());

    res.status(200).json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get current user profile
// @route   GET /api/auth/me
// @access  Private
export const getCurrentUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await User.findById(req.user._id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    res.status(200).json({
      id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      address: user.address,
      phone: user.phone,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Update user profile
// @route   PUT /api/auth/profile
// @access  Private
export const updateProfile = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { name, email, password, avatar, address, phone } = req.body;

    // Find user
    const user = await User.findById(req.user._id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // Update fields
    if (name) user.name = name;
    if (email) user.email = email;
    if (password) user.password = password;
    if (avatar) user.avatar = avatar;
    if (address) user.address = address;
    if (phone) user.phone = phone;

    // Save user
    await user.save();

    res.status(200).json({
      id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      avatar: user.avatar,
      address: user.address,
      phone: user.phone,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Forgot password
// @route   POST /api/auth/forgot-password
// @access  Public
export const forgotPassword = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { email } = req.body;

    // Find user by email
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // Generate reset token
    const resetToken = Math.random().toString(36).slice(2, 10);
    
    // Hash token and set to resetPasswordToken field
    user.resetPasswordToken = resetToken;
    
    // Set expire
    user.resetPasswordExpire = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    
    await user.save();

    // In a real app, send email with reset token
    // For this example, we'll just return the token
    res.status(200).json({
      message: 'Password reset email sent',
      resetToken, // In a real app, don't return this
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Reset password
// @route   POST /api/auth/reset-password/:token
// @access  Public
export const resetPassword = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { token } = req.params;
    const { password } = req.body;

    // Find user by reset token and check if it's expired
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpire: { $gt: Date.now() },
    });

    if (!user) {
      return res.status(400).json({
        message: 'Invalid or expired token',
      });
    }

    // Set new password
    user.password = password;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpire = undefined;
    
    await user.save();

    // Generate new token
    const newToken = generateToken(user._id.toString());

    res.status(200).json({
      message: 'Password reset successful',
      token: newToken,
    });
  } catch (error) {
    next(error);
  }
};

import { Request, Response, NextFunction } from 'express';
import { Order, IOrder } from '../models/order.model';
import { Product } from '../models/product.model';
import { Cart } from '../models/cart.model';

// @desc    Create new order
// @route   POST /api/orders
// @access  Private
export const createOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const {
      orderItems,
      shippingAddress,
      paymentMethod,
    } = req.body;

    if (!orderItems || orderItems.length === 0) {
      return res.status(400).json({
        message: 'No order items',
      });
    }

    // Verify all products exist and have sufficient stock
    for (const item of orderItems) {
      const product = await Product.findById(item.product);
      
      if (!product) {
        return res.status(404).json({
          message: `Product not found: ${item.product}`,
        });
      }
      
      if (product.stock < item.quantity) {
        return res.status(400).json({
          message: `Not enough stock for ${product.name}. Available: ${product.stock}`,
        });
      }
    }

    // Calculate prices
    const itemsPrice = orderItems.reduce(
      (acc, item) => acc + item.price * item.quantity,
      0
    );
    
    // Apply tax (example: 10%)
    const taxRate = 0.1;
    const taxPrice = itemsPrice * taxRate;
    
    // Calculate shipping (example: free shipping over $100, otherwise $10)
    const shippingPrice = itemsPrice > 100 ? 0 : 10;
    
    // Total price
    const totalPrice = itemsPrice + taxPrice + shippingPrice;

    // Create order
    const order = await Order.create({
      user: req.user._id,
      orderItems,
      shippingAddress,
      paymentMethod,
      itemsPrice,
      taxPrice,
      shippingPrice,
      totalPrice,
    });

    // Update product stock
    for (const item of orderItems) {
      const product = await Product.findById(item.product);
      if (product) {
        product.stock -= item.quantity;
        await product.save();
      }
    }

    // Clear user's cart
    await Cart.findOneAndUpdate(
      { user: req.user._id },
      { $set: { items: [], totalPrice: 0 } }
    );

    res.status(201).json(order);
  } catch (error) {
    next(error);
  }
};

// @desc    Get order by ID
// @route   GET /api/orders/:id
// @access  Private
export const getOrderById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Check if the order belongs to the user or if the user is an admin
    if (
      order.user.toString() !== req.user._id.toString() &&
      req.user.role !== 'admin'
    ) {
      return res.status(403).json({
        message: 'Not authorized to access this order',
      });
    }

    res.status(200).json(order);
  } catch (error) {
    next(error);
  }
};

// @desc    Update order to paid
// @route   PUT /api/orders/:id/pay
// @access  Private
export const updateOrderToPaid = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Update order
    order.isPaid = true;
    order.paidAt = new Date();
    order.status = 'processing';
    order.paymentResult = {
      id: req.body.id,
      status: req.body.status,
      update_time: req.body.update_time,
      email_address: req.body.email_address,
    };

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

// @desc    Update order to delivered
// @route   PUT /api/orders/:id/deliver
// @access  Private/Admin
export const updateOrderToDelivered = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Update order
    order.isDelivered = true;
    order.deliveredAt = new Date();
    order.status = 'delivered';
    order.trackingNumber = req.body.trackingNumber || order.trackingNumber;

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

// @desc    Update order status
// @route   PUT /api/orders/:id/status
// @access  Private/Admin
export const updateOrderStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { status, trackingNumber } = req.body;

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Update order status
    order.status = status;
    
    // If status is shipped, update tracking number
    if (status === 'shipped' && trackingNumber) {
      order.trackingNumber = trackingNumber;
    }
    
    // If status is delivered, update delivered status
    if (status === 'delivered') {
      order.isDelivered = true;
      order.deliveredAt = new Date();
    }

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

// @desc    Get logged in user orders
// @route   GET /api/orders/myorders
// @access  Private
export const getMyOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const orders = await Order.find({ user: req.user._id }).sort({
      createdAt: -1,
    });

    res.status(200).json(orders);
  } catch (error) {
    next(error);
  }
};

// @desc    Get all orders
// @route   GET /api/orders
// @access  Private/Admin
export const getOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { 
      status, 
      page = 1, 
      limit = 10,
      sort = 'createdAt',
      order = 'desc'
    } = req.query;

    // Build filter
    const filter: any = {};
    if (status) {
      filter.status = status;
    }

    // Build sort
    const sortOption: any = {};
    sortOption[sort as string] = order === 'desc' ? -1 : 1;

    // Calculate pagination
    const pageNum = Number(page);
    const limitNum = Number(limit);
    const skip = (pageNum - 1) * limitNum;

    // Get orders
    const orders = await Order.find(filter)
      .populate('user', 'id name email')
      .sort(sortOption)
      .skip(skip)
      .limit(limitNum);

    // Get total count
    const total = await Order.countDocuments(filter);

    res.status(200).json({
      orders,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      total,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Cancel order
// @route   PUT /api/orders/:id/cancel
// @access  Private
export const cancelOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        message: 'Order not found',
      });
    }

    // Check if the order belongs to the user or if the user is an admin
    if (
      order.user.toString() !== req.user._id.toString() &&
      req.user.role !== 'admin'
    ) {
      return res.status(403).json({
        message: 'Not authorized to cancel this order',
      });
    }

    // Check if order can be cancelled
    if (order.status === 'delivered' || order.status === 'shipped') {
      return res.status(400).json({
        message: 'Cannot cancel an order that has been shipped or delivered',
      });
    }

    // Update order status
    order.status = 'cancelled';

    // Restore product stock
    for (const item of order.orderItems) {
      const product = await Product.findById(item.product);
      if (product) {
        product.stock += item.quantity;
        await product.save();
      }
    }

    const updatedOrder = await order.save();

    res.status(200).json(updatedOrder);
  } catch (error) {
    next(error);
  }
};

import { Request, Response, NextFunction } from 'express';
import { User, IUser } from '../models/user.model';

// @desc    Get all users
// @route   GET /api/users
// @access  Private/Admin
export const getUsers = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { 
      page = 1, 
      limit = 10,
      sort = 'createdAt',
      order = 'desc',
      search
    } = req.query;

    // Build filter
    const filter: any = {};
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
      ];
    }

    // Build sort
    const sortOption: any = {};
    sortOption[sort as string] = order === 'desc' ? -1 : 1;

    // Calculate pagination
    const pageNum = Number(page);
    const limitNum = Number(limit);
    const skip = (pageNum - 1) * limitNum;

    // Get users
    const users = await User.find(filter)
      .select('-password')
      .sort(sortOption)
      .skip(skip)
      .limit(limitNum);

    // Get total count
    const total = await User.countDocuments(filter);

    res.status(200).json({
      users,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      total,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get user by ID
// @route   GET /api/users/:id
// @access  Private/Admin
export const getUserById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id).select('-password');

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    res.status(200).json(user);
  } catch (error) {
    next(error);
  }
};

// @desc    Update user
// @route   PUT /api/users/:id
// @access  Private/Admin
export const updateUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    const { name, email, role, isVerified } = req.body;

    // Update fields
    if (name) user.name = name;
    if (email) user.email = email;
    if (role) user.role = role;
    if (isVerified !== undefined) user.isVerified = isVerified;

    const updatedUser = await user.save();

    res.status(200).json({
      id: updatedUser._id,
      name: updatedUser.name,
      email: updatedUser.email,
      role: updatedUser.role,
      isVerified: updatedUser.isVerified,
      createdAt: updatedUser.createdAt,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Delete user
// @route   DELETE /api/users/:id
// @access  Private/Admin
export const deleteUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // Prevent admin from deleting themselves
    if (user._id.toString() === req.user._id.toString()) {
      return res.status(400).json({
        message: 'Cannot delete your own account',
      });
    }

    await user.deleteOne();

    res.status(200).json({ message: 'User removed' });
  } catch (error) {
    next(error);
  }
};

// @desc    Get user orders
// @route   GET /api/users/:id/orders
// @access  Private/Admin
export const getUserOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        message: 'User not found',
      });
    }

    // This would typically use a model import, but for simplicity we'll use a direct import
    const Order = require('../models/order.model').Order;
    
    const orders = await Order.find({ user: req.params.id }).sort({
      createdAt: -1,
    });

    res.status(200).json(orders);
  } catch (error) {
    next(error);
  }
};

import { Request, Response, NextFunction } from 'express';
import { Category, ICategory } from '../models/category.model';

// @desc    Get all categories
// @route   GET /api/categories
// @access  Public
export const getCategories = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { parent, level } = req.query;
    
    // Build filter
    const filter: any = {};
    if (parent) {
      filter.parent = parent;
    } else if (parent === 'null') {
      filter.parent = null;
    }
    
    if (level) {
      filter.level = Number(level);
    }

    const categories = await Category.find(filter).sort({ name: 1 });

    res.status(200).json(categories);
  } catch (error) {
    next(error);
  }
};

// @desc    Get category by ID
// @route   GET /api/categories/:id
// @access  Public
export const getCategoryById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const category = await Category.findById(req.params.id);

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    res.status(200).json(category);
  } catch (error) {
    next(error);
  }
};

// @desc    Get category by slug
// @route   GET /api/categories/slug/:slug
// @access  Public
export const getCategoryBySlug = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const category = await Category.findOne({ slug: req.params.slug });

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    res.status(200).json(category);
  } catch (error) {
    next(error);
  }
};

// @desc    Create a category
// @route   POST /api/categories
// @access  Private/Admin
export const createCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const { name, description, image, parent } = req.body;

    // Check if category with same name exists
    const existingCategory = await Category.findOne({ name });
    if (existingCategory) {
      return res.status(400).json({
        message: 'Category with this name already exists',
      });
    }

    // Create category
    const category = await Category.create({
      name,
      description,
      image,
      parent,
    });

    res.status(201).json(category);
  } catch (error) {
    next(error);
  }
};

// @desc    Update a category
// @route   PUT /api/categories/:id
// @access  Private/Admin
export const updateCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const category = await Category.findById(req.params.id);

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    const { name, description, image, parent, isActive } = req.body;

    // If name is changed, check if it already exists
    if (name && name !== category.name) {
      const existingCategory = await Category.findOne({ name });
      if (existingCategory) {
        return res.status(400).json({
          message: 'Category with this name already exists',
        });
      }
    }

    // Update category fields
    if (name) category.name = name;
    if (description !== undefined) category.description = description;
    if (image !== undefined) category.image = image;
    if (parent !== undefined) category.parent = parent;
    if (isActive !== undefined) category.isActive = isActive;

    const updatedCategory = await category.save();

    res.status(200).json(updatedCategory);
  } catch (error) {
    next(error);
  }
};

// @desc    Delete a category
// @route   DELETE /api/categories/:id
// @access  Private/Admin
export const deleteCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const category = await Category.findById(req.params.id);

    if (!category) {
      return res.status(404).json({
        message: 'Category not found',
      });
    }

    // Check if category has subcategories
    const hasSubcategories = await Category.exists({ parent: category._id });
    if (hasSubcategories) {
      return res.status(400).json({
        message: 'Cannot delete category with subcategories',
      });
    }

    // Check if category has products
    const Product = require('../models/product.model').Product;
    const hasProducts = await Product.exists({ category: category.name });
    if (hasProducts) {
      return res.status(400).json({
        message: 'Cannot delete category with products',
      });
    }

    await category.deleteOne();

    res.status(200).json({ message: 'Category removed' });
  } catch (error) {
    next(error);
  }
};

// @desc    Get category tree
// @route   GET /api/categories/tree
// @access  Public
export const getCategoryTree = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get all parent categories
    const parentCategories = await Category.find({ parent: null }).sort({ name: 1 });
    
    // For each parent category, get its subcategories
    const categoryTree = await Promise.all(
      parentCategories.map(async (parent) => {
        const subcategories = await Category.find({ parent: parent._id }).sort({ name: 1 });
        
        return {
          _id: parent._id,
          name: parent.name,
          slug: parent.slug,
          description: parent.description,
          image: parent.image,
          level: parent.level,
          isActive: parent.isActive,
          subcategories: subcategories.map((sub) => ({
            _id: sub._id,
            name: sub.name,
            slug: sub.slug,
            description: sub.description,
            image: sub.image,
            level: sub.level,
            isActive: sub.isActive,
          })),
        };
      })
    );
    
    res.status(200).json(categoryTree);
  } catch (error) {
    next(error);
  }
};

import { Request, Response, NextFunction } from 'express';
import { Cart, ICart } from '../models/cart.model';
import { Product } from '../models/product.model';

// @desc    Get user cart
// @route   GET /api/cart
// @access  Private
export const getCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    let cart = await Cart.findOne({ user: req.user._id });

    if (!cart) {
      // Create empty cart if none exists
      cart = await Cart.create({
        user: req.user._id,
        items: [],
        totalPrice: 0,
      });
    }

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Add item to cart
// @route   POST /api/cart/items
// @access  Private
export const addToCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { productId, quantity = 1 } = req.body;

    // Validate product exists
    const product = await Product.findById(productId);
    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Check if product is in stock
    if (product.stock < quantity) {
      return res.status(400).json({
        message: `Not enough stock. Available: ${product.stock}`,
      });
    }

    // Get or create cart
    let cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      cart = await Cart.create({
        user: req.user._id,
        items: [],
        totalPrice: 0,
      });
    }

    // Check if product already in cart
    const existingItemIndex = cart.items.findIndex(
      (item) => item.product.toString() === productId
    );

    if (existingItemIndex !== -1) {
      // Update quantity if product already in cart
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item to cart
      cart.items.push({
        product: product._id,
        name: product.name,
        quantity,
        price: product.price,
        image: product.images[0],
      });
    }

    // Calculate total price
    cart.totalPrice = cart.calculateTotalPrice();

    // Save cart
    await cart.save();

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Update cart item quantity
// @route   PUT /api/cart/items/:productId
// @access  Private
export const updateCartItem = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { productId } = req.params;
    const { quantity } = req.body;

    if (quantity < 1) {
      return res.status(400).json({
        message: 'Quantity must be at least 1',
      });
    }

    // Validate product exists
    const product = await Product.findById(productId);
    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Check if product is in stock
    if (product.stock < quantity) {
      return res.status(400).json({
        message: `Not enough stock. Available: ${product.stock}`,
      });
    }

    // Get cart
    const cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      return res.status(404).json({
        message: 'Cart not found',
      });
    }

    // Find item in cart
    const itemIndex = cart.items.findIndex(
      (item) => item.product.toString() === productId
    );

    if (itemIndex === -1) {
      return res.status(404).json({
        message: 'Item not found in cart',
      });
    }

    // Update quantity
    cart.items[itemIndex].quantity = quantity;

    // Calculate total price
    cart.totalPrice = cart.calculateTotalPrice();

    // Save cart
    await cart.save();

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Remove item from cart
// @route   DELETE /api/cart/items/:productId
// @access  Private
export const removeFromCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { productId } = req.params;

    // Get cart
    const cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      return res.status(404).json({
        message: 'Cart not found',
      });
    }

    // Remove item from cart
    cart.items = cart.items.filter(
      (item) => item.product.toString() !== productId
    );

    // Calculate total price
    cart.totalPrice = cart.calculateTotalPrice();

    // Save cart
    await cart.save();

    res.status(200).json(cart);
  } catch (error) {
    next(error);
  }
};

// @desc    Clear cart
// @route   DELETE /api/cart
// @access  Private
export const clearCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get cart
    const cart = await Cart.findOne({ user: req.user._id });
    if (!cart) {
      return res.status(404).json({
        message: 'Cart not found',
      });
    }

    // Clear cart
    cart.items = [];
    cart.totalPrice = 0;

    // Save cart
    await cart.save();

    res.status(200).json({ message: 'Cart cleared' });
  } catch (error) {
    next(error);
  }
};

import { Request, Response, NextFunction } from 'express';
import { Product, IProduct } from '../models/product.model';
import { User } from '../models/user.model';

// @desc    Get all products
// @route   GET /api/products
// @access  Public
export const getProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { 
      category, 
      brand, 
      search, 
      sort, 
      min, 
      max, 
      page = 1, 
      limit = 10,
      featured,
      isNew,
      onSale
    } = req.query;

    // Build filter object
    const filter: any = {};
    
    if (category) {
      filter.category = category;
    }
    
    if (brand) {
      filter.brand = brand;
    }
    
    if (search) {
      filter.$text = { $search: search as string };
    }
    
    if (min || max) {
      filter.price = {};
      if (min) filter.price.$gte = Number(min);
      if (max) filter.price.$lte = Number(max);
    }

    if (featured === 'true') {
      filter.featured = true;
    }

    if (isNew === 'true') {
      filter.isNew = true;
    }

    if (onSale === 'true') {
      filter.onSale = true;
    }

    // Build sort object
    let sortOption = {};
    if (sort) {
      switch (sort) {
        case 'price':
          sortOption = { price: 1 };
          break;
        case 'price-desc':
          sortOption = { price: -1 };
          break;
        case 'name':
          sortOption = { name: 1 };
          break;
        case 'name-desc':
          sortOption = { name: -1 };
          break;
        case 'newest':
          sortOption = { createdAt: -1 };
          break;
        case 'rating':
          sortOption = { rating: -1 };
          break;
        default:
          sortOption = { createdAt: -1 };
      }
    } else {
      sortOption = { createdAt: -1 };
    }

    // Calculate pagination
    const pageNum = Number(page);
    const limitNum = Number(limit);
    const skip = (pageNum - 1) * limitNum;

    // Execute query
    const products = await Product.find(filter)
      .sort(sortOption)
      .skip(skip)
      .limit(limitNum);

    // Get total count for pagination
    const total = await Product.countDocuments(filter);

    res.status(200).json({
      products,
      page: pageNum,
      pages: Math.ceil(total / limitNum),
      total,
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get product by ID
// @route   GET /api/products/:id
// @access  Public
export const getProductById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    res.status(200).json(product);
  } catch (error) {
    next(error);
  }
};

// @desc    Create a product
// @route   POST /api/products
// @access  Private/Admin
export const createProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const {
      name,
      description,
      shortDescription,
      price,
      originalPrice,
      images,
      category,
      brand,
      stock,
      sku,
      featured,
      isNew,
      onSale,
      tags,
      attributes,
    } = req.body;

    // Check if product with same SKU exists
    const existingProduct = await Product.findOne({ sku });
    if (existingProduct) {
      return res.status(400).json({
        message: 'Product with this SKU already exists',
      });
    }

    // Create product
    const product = await Product.create({
      name,
      description,
      shortDescription,
      price,
      originalPrice,
      images,
      category,
      brand,
      stock,
      sku,
      featured: featured || false,
      isNew: isNew || false,
      onSale: onSale || false,
      tags: tags || [],
      attributes: attributes || {},
      rating: 0,
      numReviews: 0,
      reviews: [],
    });

    res.status(201).json(product);
  } catch (error) {
    next(error);
  }
};

// @desc    Update a product
// @route   PUT /api/products/:id
// @access  Private/Admin
export const updateProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Update product fields
    const updatedProduct = await Product.findByIdAndUpdate(
      req.params.id,
      { $set: req.body },
      { new: true, runValidators: true }
    );

    res.status(200).json(updatedProduct);
  } catch (error) {
    next(error);
  }
};

// @desc    Delete a product
// @route   DELETE /api/products/:id
// @access  Private/Admin
export const deleteProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        message: 'Not authorized, admin only',
      });
    }

    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    await product.deleteOne();

    res.status(200).json({ message: 'Product removed' });
  } catch (error) {
    next(error);
  }
};

// @desc    Create new review
// @route   POST /api/products/:id/reviews
// @access  Private
export const createProductReview = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { rating, comment } = req.body;

    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    // Check if user already reviewed this product
    const alreadyReviewed = product.reviews.find(
      (r) => r.user.toString() === req.user._id.toString()
    );

    if (alreadyReviewed) {
      return res.status(400).json({
        message: 'Product already reviewed',
      });
    }

    // Create review
    const review = {
      user: req.user._id,
      name: req.user.name,
      rating: Number(rating),
      comment,
      date: new Date(),
    };

    // Add review to product
    product.reviews.push(review);
    
    // Update product rating
    product.numReviews = product.reviews.length;
    product.rating =
      product.reviews.reduce((acc, item) => item.rating + acc, 0) /
      product.reviews.length;

    await product.save();

    res.status(201).json({ message: 'Review added' });
  } catch (error) {
    next(error);
  }
};

// @desc    Get top rated products
// @route   GET /api/products/top
// @access  Public
export const getTopProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const limit = Number(req.query.limit) || 5;
    
    const products = await Product.find({})
      .sort({ rating: -1 })
      .limit(limit);

    res.status(200).json(products);
  } catch (error) {
    next(error);
  }
};

// @desc    Get related products
// @route   GET /api/products/:id/related
// @access  Public
export const getRelatedProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const product = await Product.findById(req.params.id);

    if (!product) {
      return res.status(404).json({
        message: 'Product not found',
      });
    }

    const limit = Number(req.query.limit) || 4;

    // Find products in the same category, excluding the current product
    const relatedProducts = await Product.find({
      _id: { $ne: product._id },
      category: product.category,
    })
      .limit(limit);

    res.status(200).json(relatedProducts);
  } catch (error) {
    next(error);
  }
};

import express from 'express';
import {
  getUsers,
  getUserById,
  updateUser,
  deleteUser,
  getUserOrders,
} from '../controllers/user.controller';
import { authMiddleware, adminMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// All routes are protected and admin-only
router.use(authMiddleware, adminMiddleware);

router.get('/', getUsers);
router.get('/:id', getUserById);
router.put('/:id', updateUser);
router.delete('/:id', deleteUser);
router.get('/:id/orders', getUserOrders);

export default router;

import express from 'express';
import {
  getProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct,
  createProductReview,
  getTopProducts,
  getRelatedProducts,
} from '../controllers/product.controller';
import { authMiddleware, adminMiddleware, optionalAuthMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Public routes
router.get('/', optionalAuthMiddleware, getProducts);
router.get('/top', getTopProducts);
router.get('/:id', getProductById);
router.get('/:id/related', getRelatedProducts);

// Protected routes
router.post('/:id/reviews', authMiddleware, createProductReview);

// Admin routes
router.post('/', authMiddleware, adminMiddleware, createProduct);
router.put('/:id', authMiddleware, adminMiddleware, updateProduct);
router.delete('/:id', authMiddleware, adminMiddleware, deleteProduct);

export default router;

import express from 'express';
import {
  getCategories,
  getCategoryById,
  getCategoryBySlug,
  createCategory,
  updateCategory,
  deleteCategory,
  getCategoryTree,
} from '../controllers/category.controller';
import { authMiddleware, adminMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Public routes
router.get('/', getCategories);
router.get('/tree', getCategoryTree);
router.get('/slug/:slug', getCategoryBySlug);
router.get('/:id', getCategoryById);

// Admin routes
router.post('/', authMiddleware, adminMiddleware, createCategory);
router.put('/:id', authMiddleware, adminMiddleware, updateCategory);
router.delete('/:id', authMiddleware, adminMiddleware, deleteCategory);

export default router;

import express from 'express';
import {
  createOrder,
  getOrderById,
  updateOrderToPaid,
  updateOrderToDelivered,
  updateOrderStatus,
  getMyOrders,
  getOrders,
  cancelOrder,
} from '../controllers/order.controller';
import { authMiddleware, adminMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Protected routes
router.post('/', authMiddleware, createOrder);
router.get('/myorders', authMiddleware, getMyOrders);
router.get('/:id', authMiddleware, getOrderById);
router.put('/:id/pay', authMiddleware, updateOrderToPaid);
router.put('/:id/cancel', authMiddleware, cancelOrder);

// Admin routes
router.get('/', authMiddleware, adminMiddleware, getOrders);
router.put('/:id/deliver', authMiddleware, adminMiddleware, updateOrderToDelivered);
router.put('/:id/status', authMiddleware, adminMiddleware, updateOrderStatus);

export default router;

import express from 'express';
import {
  getCart,
  addToCart,
  updateCartItem,
  removeFromCart,
  clearCart,
} from '../controllers/cart.controller';
import { authMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// All routes are protected
router.get('/', authMiddleware, getCart);
router.post('/items', authMiddleware, addToCart);
router.put('/items/:productId', authMiddleware, updateCartItem);
router.delete('/items/:productId', authMiddleware, removeFromCart);
router.delete('/', authMiddleware, clearCart);

export default router;

import express from 'express';
import {
  register,
  login,
  getCurrentUser,
  updateProfile,
  forgotPassword,
  resetPassword,
} from '../controllers/auth.controller';
import { authMiddleware } from '../middleware/auth.middleware';

const router = express.Router();

// Public routes
router.post('/register', register);
router.post('/login', login);
router.post('/forgot-password', forgotPassword);
router.post('/reset-password/:token', resetPassword);

// Protected routes
router.get('/me', authMiddleware, getCurrentUser);
router.put('/profile', authMiddleware, updateProfile);

export default router;

